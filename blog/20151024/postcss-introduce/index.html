
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>PostCSS是个什么鬼东西？ - 小撸</title>
  <meta name="author" content="小撸">

  
  <meta name="description" content="前言 最近大漠前辈在群里发关于PostCSS的系列文章，但是耗子姐姐又说看了有点云里雾里的感觉，所以这篇文章将按一个思考的角度来理解一下 PostCSS 到底是一个什么东西。 一、提出不懂的地方 很多时候第一次在网上查询 PostCSS 概念的时候，大家都解释成一个后处理器的概念， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fegg.github.io/blog/20151024/postcss-introduce/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小撸" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小撸</a></h1>
  
    <h2>Follow Your Heart.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="fegg.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">主页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">PostCSS是个什么鬼东西？</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-24T00:00:00+08:00'><span class='date'>2015 年10 月24 日</span> <span class='time'>12:00 am</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://fegg.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h3 id="section">前言</h3>

<p>最近大漠前辈在群里发关于<code>PostCSS</code>的系列文章，但是耗子姐姐又说看了有点云里雾里的感觉，所以这篇文章将按一个思考的角度来理解一下 PostCSS 到底是一个什么东西。</p>

<p><img src="/images/postcss/top.png" alt="配图" /></p>

<h3 id="section-1">一、提出不懂的地方</h3>

<p>很多时候第一次在网上查询 PostCSS 概念的时候，大家都解释成一个<code>后处理器</code>的概念，其实个人觉得这些概念不重要，更为重要的有以下几点：</p>

<ol>
  <li>它本质上是一个什么东西？</li>
  <li>它能解决我们什么问题？</li>
  <li>它是通过什么方式来解决我们的问题？</li>
  <li>它解决我们的问题是为什么？</li>
  <li>怎么实现与 <code>SASS</code>、<code>LESS</code>、<code>Stylus</code> 相同的功能（因为它们被经常拿来比较）</li>
  <li>它由哪些东西组成？</li>
  <li>既然是程序可以用的，那么它的API呢？</li>
</ol>

<!-- more -->

<hr />

<p>Q: 这个时候，你应该会问：<strong>为什么要将组成和API放到最后呢？</strong></p>

<p>A: 那是因为我们在认识一个不太清楚的东西的时候，第一次肯定是一个直观的认识：它到底有什么用？而不会说，一来就去深入的研究它。不过这里本质还是要先说一下的，先留个印象。</p>

<hr />

<h3 id="section-2">二、个个击破</h3>

<h4 id="section-3">1. 它本质上是一个什么东西？</h4>

<ul>
  <li>PostCSS 可以直观的理解为：它就是一个<code>平台、平台、平台</code>，重要的事情来三遍比较爽，哈哈！</li>
</ul>

<blockquote>
  <p>为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大。</p>
</blockquote>

<ul>
  <li>PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）。</li>
</ul>

<p>上面两条看完后，我们可以理解为下面这个模型。</p>

<p><img src="/images/postcss/process.png" alt="基本模型" /></p>

<p>所以说，PostCSS 它需要一个插件系统才能够发挥作用。我们可以通过“插件”来传递AST，然后再把AST转换成一个串，最后再输出到目标文件中去。当然，这里是有API可以用，这里先不讲，免得晕了。</p>

<h4 id="section-4">2. 它能解决我们什么问题？它是通过什么方式来解决我们的问题？</h4>

<p>上面的图很清晰，但是我还是不知道是个什么东西！所以接下来温和点，直接从代码层面来感官的认识一下。</p>

<ul>
  <li>它能够为 CSS 提供额外的功能；</li>
  <li>通过在 PostCSS 这个<code>平台</code>上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer</li>
  <li>我们能够使用JavaScript来开发插件（这点对前端来说很重要）</li>
</ul>

<p>好吧，看到一个熟悉的单词了：autoprefixer，这里我们就让它来当栗子吧，可能更容易理解一点。</p>

<p>首先，我们需要做一些准备，安装好需要的东西。</p>

<pre><code>// postcss 的命令行工具
sudo npm install  -g postcss-cli
// autoprefixer 插件
sudo npm install -g autoprefixer
</code></pre>

<p>第一次用命令行能让你更直观去理解它哈，所以请要有一颗折腾的心。</p>

<pre><code>// 1. 先看下这个命令有哪些参数可以用
postcss --help

Usage: /usr/local/bin/postcss -use plugin [--config|-c config.json] [--output|-o
output.css] [input.css]

选项：
  -c, --config       JSON file with plugin configuration
  -u, --use          postcss plugin name (can be used multiple times)
  -o, --output       Output file (stdout if not provided)
  -d, --dir          Output directory
  -r, --replace      Replace input file(s) with generated output       [boolean]
  -s, --syntax       Alternative input syntax parser
  -p, --parser       Alternative CSS parser
  -t, --stringifier  Alternative output stringifier
  -w, --watch        auto-recompile when detecting source changes
  -v, --version      显示版本号                                        [boolean]
  -h, --help         显示帮助信息                                      [boolean]

示例：
  postcss --use autoprefixer -c             Use autoprefixer as a postcss plugin
  options.json -o screen.css screen.css
  postcss --use autoprefixer                Pass plugin parameters in
  --autoprefixer.browsers "&gt; 5%" -o         plugin.option notation
  screen.css screen.css
  postcss -u postcss-cachify -u             Use multiple plugins and multiple
  autoprefixer -d build *.css               input files

Please specify at least one plugin name.
</code></pre>

<p>PS: 我贴出来是方便大家在看的时候不用电脑……^_^</p>

<p>好吧，先看一下文件目录，这里我只说一下比较好写的方式，就是将一些参数配置到配置文件中去。</p>

<p><img src="/images/postcss/menu.png" alt="目录结构" /></p>

<pre><code>// config.json: 所有的配置
// p.json: 仅有 autoprefixer 插件的配置

// config.json 的内容
{
	"use": ["autoprefixer"],
	"input": "src/index.css",
	"output": "index.css",
	"autoprefixer": {
		"browsers": "&gt; 5%"
	}
}

// p.json 的内容
{
	"autoprefixer": {
		"browsers": "&gt; 5%"
	}
}
</code></pre>

<p>接下来我们在终端里面输入：</p>

<pre><code>// 最简洁的方式
postcss -c config.json
// 稍微复杂一点的方式，这里要用 -i 参数，help里面没有，我是从config.json里面的配置猜出来的，官方的那个写法出不来
postcss -u autoprefixer -c p.json -i src/index.css -o index.css
// 最复杂的方式
// 还是不写比较好。。。
</code></pre>

<p>跟平时想到的效果一样：</p>

<pre><code>// src/index.css 中的源码
* {
	transition: all .1s;
}
// 转换过后的代码 index.css
* {
	-webkit-transition: all .1s;
        transition: all .1s;
}
</code></pre>

<p>好吧，现在肯定就对 PostCSS 有一个感官的认识了，接下来就是需要自己动手去用一下 <code>cssnext</code> 这个插件了～看会发生什么，这里就不写了，也挺好用的，不过应该还是草案状态。</p>

<hr />

<p>我们开发不可能用命令行吧，所以这里再接着介绍代码编写，然后用 node 去执行文件的方式。直接上代码吧。</p>

<pre><code>// 1. 先安装一下需要的库
npm install postcss --save-dev
npm install autoprefixer --save-dev

// 2. 其实应该先看看 postcss 的 package.json 文件，来看看包含了些什么，留个印象

// 3. p.js 中的代码
var postcss = require('postcss');
var autoprefixer = require('autoprefixer');
var fs = require('fs');

var css = '* { transition: all .1s; }';

postcss([autoprefixer])
	.process(css)
	.then(function(result) {
		// 这一行是学习的时候需要的，看一下到底对象里面包含什么
		console.log(result);
		if (result.css) {
			fs.writeFileSync('index.css', result.css);
		}
		if (result.map) {
			fs.writeFileSync('index.css.map', result.map);
		}
	});

// 4. 执行 p.js
node p
</code></pre>

<p>好吧，最后的结果和之前用命令行的方式一样，只不过过程不同。这样下来应该对 PostCSS 有了更多的感觉了吧。还没完，不用慌～我们还需要提出一个问题，我都有 <code>SASS</code> 等预处理器了，还拿它来不是又给前端届添乱么？因为这2年东西确实太多了～</p>

<blockquote>
  <p>记住一句话：存在即合理</p>
</blockquote>

<p>既然合理，那么我们就看看它有什么优势呗～</p>

<h4 id="section-5">3. 它解决我们的问题是为什么？优势何在？</h4>

<p>比如，我们用 SASS 来处理 box-shadow 的前缀，我们需要这样写：</p>

<pre><code>/* CSS3 box-shadow */
@mixin box-shadow($top, $left, $blur, $size, $color, $inset: false) {
	@if $inset {
		-webkit-box-shadow: inset $top $left $blur $size $color;
		box-shadow: inset $top $left $blur $size $color;
	} @else {
		-webkit-box-shadow: $top $left $blur $size $color;
		box-shadow: $top $left $blur $size $color;
	}
}
</code></pre>

<p>使用 PostCSS 我们只需要按标准的 CSS 来写就行了，因为最后 autoprefixer 会帮我们做添加这个事情～</p>

<pre><code>box-shadow: 0 0 3px 5px rgba(222, 222, 222, .3);
</code></pre>

<p>所以，这里就出现了一个经常大家说的未来编码的问题。实际上，PostCSS 改变的是一种开发模式。</p>

<ul>
  <li>SASS等工具：源代码 -&gt; 生产环境 CSS</li>
  <li>PostCSS：源代码 -&gt; 标准 CSS -&gt; 生产环境 CSS</li>
</ul>

<p>这样能体会出优势吧，但是目前大家都是 SASS + PostCSS 这样的开发模式，其实我认为是不错的，取长补短嘛，当然，在 PostCSS 平台上都是可以做到的，只是目前这个过渡期，这样更好，更工程化。接下来我就介绍一些方法来纯粹是用 PostCSS。</p>

<h4 id="sasslessstylus-">4. 怎么实现与 SASS、LESS、Stylus 相同的功能</h4>

<p>其实这一节我都不需要写了～列一下插件就行了，因为插件才是实现，PostCSS 只是提供了一个平台。</p>

<p>其实可以去官方看看：<a href="https://github.com/postcss/postcss">插件系统</a>
这里列几个便于理解的插件</p>

<ul>
  <li>postcss-each</li>
  <li>postcss-for</li>
  <li>postcss-mixins</li>
  <li>postcss-extend</li>
</ul>

<p>从名字就能看出来了吧～应该很好理解。</p>

<h4 id="section-6">5. 它由哪些东西组成？</h4>

<p>其实从官方介绍来看，只包含以下内容：</p>

<ol>
  <li>CSS Parser</li>
  <li>CSS 节点树 API</li>
  <li>source map 生成器</li>
  <li>生成节点树串</li>
</ol>

<p>英文不太好 ＝＝ ，就这 4 部分吧，从第一个图其实也能够看出来。</p>

<p>其中的 I/O 体现在什么地方呢？好吧，很容易想到，主要体现在：</p>

<ul>
  <li>Input: <strong>插件程式</strong>和<strong>CSS Parser</strong></li>
  <li>Output: <strong>生成节点树串</strong></li>
</ul>

<p>CSS Parser 可以理解为一个内部过程，而插件程式主要体现在：</p>

<pre><code>postcss([ autoprefixer ])
</code></pre>

<p>最后生成的节点树串体现在：</p>

<pre><code>postcss().process().then(function (result) {
	// 就是这里了
	console.log(result.css);
});

// 现在我贴一下上面 result 对象的一个输出结果
// 这里我多引入了一个 cssnano 插件
// 改变的代码就这点，为了更全的看 result
var opts = {
	from: 'src/index.css',
	to: 'index.css',
	// 配置 map
	map: { inline: false }
};
postcss([ autoprefixer, cssnano() ]).process(css, opts)

Result {
	processor: Processor {
		// 处理器的版本号
		version: '5.0.10',
		// 加载的一堆插件
		plugins: [
			[Object], [Object], [Object], [Object], [Object],
			[Object], [Object], [Object], [Object], [Object],
			[Object], [Object], [Object], [Object], [Object],
			[Object], [Object], [Object], [Object], [Object],
			[Object], [Object], [Object], [Object], [Object],
			[Object], [Object]
		]
	},
	messages: [],
	root: Root {
		raws: {
			semicolon: false,
			after: ''
		},
		type: 'root',
		nodes: [
			[Object]
		],
		source: {
			input: [Object],
			start: [Object]
		},
		_autoprefixerDisabled: false,
		_autoprefixerPrefix: false,
		rawCache: {
			colon: ':',
			indent: '',
			beforeDecl: '',
			beforeRule: '',
			beforeOpen: '',
			beforeClose: '',
			beforeComment: '',
			after: '',
			emptyBody: '',
			commentLeft: '',
			commentRight: ''
		}
	},
	// 我们代码中配置 opts 变量
	opts: {
		from: 'src/index.css',
		to: 'index.css'
	},
	// 这就是重新生成的 节点树串
	// 这里有自动补全和高效压缩的效果
	css: '*{-webkit-transition:all .1s;transition:all .1s}',
	// map的文件的配置
	map: 
		SourceMapGenerator {
			_file: 'index.css',
			_sourceRoot: null,
			_skipValidation: false,
			_sources: ArraySet { _array: [Object], _set: [Object] },
			_names: ArraySet { _array: [], _set: {} },
			_mappings: MappingList { _array: [Object], _sorted: true, _last: [Object] },
			_sourcesContents: { '$src/index.css': '* { transition: all .1s; }' } },
	// 这里应该是链式要用的吧，暂时不深究
	lastPlugin: {
		[Function]
		postcssPlugin: 'cssnano-reset-stylecache',
			postcssVersion: '5.0.10'
	}
}
</code></pre>

<p>其实吧，这样有点抽象的，还是来看熟悉的 API 吧。</p>

<p>这里出现了 sourcemap，说明 PostCSS 中的转换功能是它必备的，但是必备并不等于：<strong>源代码与目标代码不能完全一致</strong>。</p>

<p>这里吐槽一下 Chrome 的 sourcemap 功能，一坨屎！下面看看 firefox 里面的效果吧。</p>

<p><img src="/images/postcss/sourcemap.png" alt="SourceMap的效果" /></p>

<p>这里 firefox 里面就自动映射了<strong>源文件</strong>，非常不错！</p>

<h4 id="api">6. 既然是程序可以用的，那么它的API呢？</h4>

<p>其实官方有 API 的详细解释，我看了一下，一看就明白了，就不再花时间介绍了，大家可以去看看，这样会知道，原来如此～</p>

<p>PS: 大家可以先看看 Node Common 和 Node相关的，然后再看 plugin</p>

<p><a href="https://github.com/postcss/postcss/blob/master/docs/api.md">官方API</a></p>

<p>这里看一个 DEMO，主要做 rem 和 px 单位之间的互换，加入 processors 就可以用了，很方便：</p>

<pre><code>var custom = function(css, opts){
	css.eachDecl(function(decl){
		decl.value = decl.value.replace(/\d+rem/, function(str){
			return 16 * parseFloat(str) + "px";
		});
	});
};
</code></pre>

<p>开发插件可以看一下 <a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">官方插件指南</a></p>

<p>更细致的地方，之后有时间的时候再写写 ^_^ 一说技术就停不下来了～</p>

<p>大家在问？我怎么在工程上应用它呢？好吧，使用 gulp, grunt, webpack 都是可以的，我觉得都理解了 PostCSS ，使用这些就很简单了，一查资料，拷贝一份配置就可以开始用了～就这样吧，下次再结合 react 来介绍一下一个叫: postcss-js 的插件，看上去还不错，还没深入用，用到的时候再分享吧。</p>

<p>其实我也是初学者，只是用了自己的学习方法来梳理成文章，下面都是我看过的文章，部分是引用的。这里就不全部举例了，看的文章有点多。。。</p>

<h4 id="section-7">7. 参考的文章</h4>

<ul>
  <li>最权威的初认识</li>
</ul>

<p><a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p>

<ul>
  <li>一个不错的东西 rework</li>
</ul>

<p><a href="https://github.com/reworkcss">https://github.com/reworkcss</a></p>

<ul>
  <li>理解 AST 等插件解析技术</li>
</ul>

<p><a href="http://rapheal.sinaapp.com/category/js/uglify%E6%BA%90%E7%A0%81/">http://rapheal.sinaapp.com/category/js/uglify%E6%BA%90%E7%A0%81/</a></p>

<ul>
  <li>大漠的系列文章，应用型很强，推荐</li>
</ul>

<p><a href="http://www.w3cplus.com/blog/tags/517.html">http://www.w3cplus.com/blog/tags/517.html</a></p>

<ul>
  <li>一个年龄差不多的开发者的解释</li>
</ul>

<p><a href="http://acgtofe.com/posts/2015/05/modular-transforming-with-postcss/">http://acgtofe.com/posts/2015/05/modular-transforming-with-postcss/</a></p>

<ul>
  <li>一篇稍微理论化解释的文章</li>
</ul>

<p><a href="http://www.oschina.net/translate/its-time-for-everyone-to-learn-about-postcss?cmp">http://www.oschina.net/translate/its-time-for-everyone-to-learn-about-postcss?cmp</a></p>

<ul>
  <li>一个开发模式简单的优劣比较</li>
</ul>

<p><a href="http://caibaojian.com/css-processor.html">http://caibaojian.com/css-processor.html</a></p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">小撸</span></span>

      




<time class='entry-date' datetime='2015-10-24T00:00:00+08:00'><span class='date'>2015 年10 月24 日</span> <span class='time'>12:00 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://fegg.github.io/blog/20151024/postcss-introduce/" data-via="lulin666000" data-counturl="http://fegg.github.io/blog/20151024/postcss-introduce/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/20151009/pro-js-2/" title="Previous Post: JavaScript的特性、函数、对象">&laquo; JavaScript的特性、函数、对象</a>
      
      
        <a class="basic-alignment right" href="/blog/20151216/hi-vue/" title="Next Post: 乱玩 Vue Todo">乱玩 Vue Todo &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20160517/redux-can-do/">Redux 能做什么？</a>
      </li>
    
      <li class="post">
        <a href="/blog/20160110/checkbox-anim/">一个好玩的 CSS 技术 CheckBox</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151216/hi-vue/">乱玩 Vue Todo</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151024/postcss-introduce/">PostCSS是个什么鬼东西？</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151009/pro-js-2/">JavaScript的特性、函数、对象</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/fegg">@fegg</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'fegg',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 小撸 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'lulin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
