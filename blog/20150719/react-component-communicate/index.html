
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>React 组件之间如何交流 - 小撸</title>
  <meta name="author" content="小撸">

  
  <meta name="description" content="前言 今天群里面有很多都在问关于 React 组件之间是如何通信的问题，之前自己写的时候也遇到过这类问题。下面是我看到的一篇不错英文版的翻译，看过我博客的人都知道，我翻译可能不会按部就班，会尽可能用中文的意思，来将作者要讲述的技术描述清楚。英文能力有限，如果有不对的地方请跟我留言，一定修改……^_ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fegg.github.io/blog/20150719/react-component-communicate/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="小撸" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">小撸</a></h1>
  
    <h2>Follow Your Heart.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="fegg.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">React 组件之间如何交流</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-19T00:00:00+08:00'><span class='date'>2015 年7 月19 日</span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>前言</h3>

<p>今天群里面有很多都在问关于 React 组件之间是如何通信的问题，之前自己写的时候也遇到过这类问题。下面是我看到的一篇不错英文版的翻译，看过我博客的人都知道，我翻译可能不会按部就班，会尽可能用中文的意思，来将作者要讲述的技术描述清楚。英文能力有限，如果有不对的地方请跟我留言，一定修改……^_^</p>

<h3>原著序</h3>

<p>处理 React 组件之间的交流方式，主要取决于组件之间的关系，然而这些关系的约定人就是你。</p>

<p>我不会讲太多关于 data-stores、data-adapters 或者 data-helpers 之类的话题。我下面只专注于 React 组件本身的交流方式的讲解。</p>

<p>React 组件之间交流的方式，可以分为以下 3 种：</p>

<ul>
<li>【父组件】向【子组件】传值；</li>
<li>【子组件】向【父组件】传值；</li>
<li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）</li>
</ul>


<!-- more -->


<h3>一、【父组件】向【子组件】传值</h3>

<blockquote><p>初步使用</p></blockquote>

<p>这个是相当容易的，在使用 React 开发的过程中经常会使用到，主要是利用 props 来进行交流。例子如下：</p>

<pre><code>// 父组件
var MyContainer = React.createClass({
  getInitialState: function () {
    return {
      checked: true
    };
  },
  render: function() {
    return (
      &lt;ToggleButton text="Toggle me" checked={this.state.checked} /&gt;
    );
  }
});

// 子组件
var ToggleButton = React.createClass({
  render: function () {
    // 从【父组件】获取的值
    var checked = this.props.checked,
        text = this.props.text;

    return (
        &lt;label&gt;{text}: &lt;input type="checkbox" checked={checked} /&gt;&lt;/label&gt;
    );
  }
});
</code></pre>

<blockquote><p>进一步讨论</p></blockquote>

<p>如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）</p>

<pre><code>// 父组件
var MyContainer = React.createClass({
  render: function() {
    return (
      &lt;Intermediate text="where is my son?" /&gt;
    );
  }
});

// 子组件1：中间嵌套的组件
var Intermediate = React.createClass({
  render: function () {
    return (
      &lt;Child text={this.props.text} /&gt;
    );
  }
});

// 子组件2：子组件1的子组件
var Child = React.createClass({
  render: function () {
    return (
      &lt;span&gt;{this.props.text}&lt;/span&gt;
    );
  }
});
</code></pre>

<h3>二、【子组件】向【父组件】传值</h3>

<p>接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。</p>

<pre><code>// 父组件
var MyContainer = React.createClass({
  getInitialState: function () {
    return {
      checked: false
    };
  },
  onChildChanged: function (newState) {
    this.setState({
      checked: newState
    });
  },
  render: function() {
    var isChecked = this.state.checked ? 'yes' : 'no';
    return (
      &lt;div&gt;
        &lt;div&gt;Are you checked: {isChecked}&lt;/div&gt;
        &lt;ToggleButton text="Toggle me"
          initialChecked={this.state.checked}
          callbackParent={this.onChildChanged}
          /&gt;
      &lt;/div&gt;
    );
  }
});

// 子组件
var ToggleButton = React.createClass({
  getInitialState: function () {
    return {
      checked: this.props.initialChecked
    };
  },
  onTextChange: function () {
    var newState = !this.state.checked;
    this.setState({
      checked: newState
    });
    // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值
    this.props.callbackParent(newState);
  },
  render: function () {
    // 从【父组件】获取的值
    var text = this.props.text;
    // 组件自身的状态数据
    var checked = this.state.checked;

    return (
        &lt;label&gt;{text}: &lt;input type="checkbox" checked={checked}                 onChange={this.onTextChange} /&gt;&lt;/label&gt;
    );
  }
});
</code></pre>

<p><img src="/images/react/demo3.gif" alt="运行效果" /></p>

<p>我觉得原文作者用代码不是很直观，接下来我话一个流程走向简图来直观描述一下这个过程：</p>

<p><img src="/images/react/comp-child-to-parent.png" alt="流程简图" /></p>

<blockquote><p>这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式</p></blockquote>

<p>这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。</p>

<h3>Tiny-Tip: React Event System</h3>

<p>在 onChange 事件或者其他 React 事件中，你能够获取以下东西：</p>

<ul>
<li>【this】：指向你的组件</li>
<li>【一个参数】：这个参数是一个 <a href="http://wiki.jikexueyuan.com/project/react/event-system.html">React 合成事件</a>，SyntheticEvent。</li>
</ul>


<p>React 对所有事件的管理都是自己实现的，与我们之前使用的 onclick、onchange 事件不一样。从根本上来说，他们都是绑定到 body 上。</p>

<pre><code>document.on('change', 'input[data-reactid=".0.2"]', function () {...});
</code></pre>

<p>上面这份代码不是来自于 React，只是打一个比方而已。</p>

<p>如果我没有猜错的话，React 真正处理一个事件的代码如下：</p>

<pre><code>var listenTo = ReactBrowserEventEmitter.listenTo;
...
function putListener(id, registrationName, listener, transaction) {
  ...
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  ...
}
// 在监听事件的内部，我们能发现如下：
target.addEventListener(eventType, callback, false);
</code></pre>

<p>这里有所有 React 支持的事件：<a href="http://reactjs.cn/react/docs/events.html">中文文档-事件系统</a></p>

<blockquote><p>多个子组件使用同一个回调的情况</p></blockquote>

<pre><code>// 父组件
var MyContainer = React.createClass({
  getInitialState: function () {
    return {
      totalChecked: 0
    };
  },
  onChildChanged: function (newState) {
    var newToral = this.state.totalChecked
      + (newState ? 1 : -1);
    this.setState({
      totalChecked: newToral
    });
  },
  render: function() {
    var totalChecked = this.state.totalChecked;
    return (
      &lt;div&gt;
        &lt;div&gt;How many are checked: {totalChecked}&lt;/div&gt;
        &lt;ToggleButton text="Toggle me"
          initialChecked={this.state.checked}
          callbackParent={this.onChildChanged}
          /&gt;
        &lt;ToggleButton text="Toggle me too"
            initialChecked={this.state.checked}
            callbackParent={this.onChildChanged}
          /&gt;
        &lt;ToggleButton text="And me"
          initialChecked={this.state.checked}
          callbackParent={this.onChildChanged}
          /&gt;
      &lt;/div&gt;
    );
  }
});

// 子组件
var ToggleButton = React.createClass({
  getInitialState: function () {
    return {
      checked: this.props.initialChecked
    };
  },
  onTextChange: function () {
    var newState = !this.state.checked;
    this.setState({
      checked: newState
    });
    // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值
    this.props.callbackParent(newState);
  },
  render: function () {
    // 从【父组件】获取的值
    var text = this.props.text;
    // 组件自身的状态数据
    var checked = this.state.checked;

    return (
        &lt;label&gt;{text}: &lt;input type="checkbox" checked={checked} onChange={this.onTextChange} /&gt;&lt;/label&gt;
    );
  }
});
</code></pre>

<p><img src="/images/react/demo4.gif" alt="运行结果" /></p>

<p>这是非常容易理解的，在父组件中我们增加了一个【totalChecked】来替代之前例子中的【checked】，当子组件改变的时候，使用同一个子组件的回调函数给父组件返回值。</p>

<h3>三、没有任何嵌套关系的组件之间传值</h3>

<p>如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。</p>

<p>下面讲介绍 3 种模式来处理事件，你能<a href="https://github.com/millermedeiros/js-signals/wiki/Comparison-between-different-Observer-Pattern-implementations">点击这里</a>来比较一下它们。</p>

<p>简单总结一下：</p>

<p>(1) Event Emitter/Target/Dispatcher</p>

<p>特点：需要一个指定的订阅源</p>

<pre><code>// to subscribe
otherObject.addEventListener(‘click’, function() { alert(‘click!’); });
// to dispatch
this.dispatchEvent(‘click’);
</code></pre>

<p>(2) Publish / Subscribe</p>

<p>特点：触发事件的时候，你不需要指定一个特定的源，因为它是使用一个全局对象来处理事件（其实就是一个全局
广播的方式来处理事件）</p>

<pre><code>// to subscribe
globalBroadcaster.subscribe(‘click’, function() { alert(‘click!’); });
// to dispatch
globalBroadcaster.publish(‘click’);
</code></pre>

<p>(3) Signals</p>

<p>特点：与Event Emitter/Target/Dispatcher相似，但是你不要使用随机的字符串作为事件触发的引用。触发事件的每一个对象都需要一个确切的名字（就是类似硬编码类的去写事件名字），并且在触发的时候，也必须要指定确切的事件。（看例子吧，很好理解）</p>

<pre><code>// to subscribe
otherObject.clicked.add(function() { alert(‘click’); });
// to dispatch
this.clicked.dispatch();
</code></pre>

<p>如果你只想简单的使用一下，并不需要其他操作，可以用简单的方式来实现：</p>

<pre><code>// 简单实现了一下 subscribe 和 dispatch
var EventEmitter = {
    _events: {},
    dispatch: function (event, data) {
        if (!this._events[event]) { // 没有监听事件
          return;
        }
        for (var i = 0; i &lt; this._events[event].length; i++) {
            this._events[event][i](data);
        }
    },
    subscribe: function (event, callback) {
      // 创建一个新事件数组
      if (!this._events[event]) {
        this._events[event] = [];
      }
      this._events[event].push(callback);
    }
};

otherObject.subscribe('namechanged', function(data) { alert(data.name); });
this.dispatch('namechanged', { name: 'John' });
</code></pre>

<p>如果你想使用 Publish/Subscribe 模型，可以使用：<a href="https://github.com/mroderick/PubSubJS">PubSubJS</a></p>

<p>React 团队使用的是：<a href="http://millermedeiros.github.io/js-signals/">js-signals</a> 它基于 Signals 模式，用起来相当不错。</p>

<h3>Events in React</h3>

<p>使用 React 事件的时候，必须关注下面两个方法：</p>

<pre><code>componentDidMount
componentWillUnmount
</code></pre>

<p>在处理事件的时候，需要注意：</p>

<p>在 componentDidMount 事件中，如果组件挂载（mounted）完成，再订阅事件；当组件卸载（unmounted）的时候，在 componentWillUnmount 事件中取消事件的订阅。</p>

<p>（如果不是很清楚可以查阅 React 对生命周期介绍的文档，里面也有描述。原文中介绍的是 componentWillMount 个人认为应该是挂载完成后订阅事件，比如Animation这个就必须挂载，并且不能动态的添加，谨慎点更好）</p>

<p>因为组件的渲染和销毁是由 React 来控制的，我们不知道怎么引用他们，所以EventEmitter 模式在处理组件的时候用处不大。</p>

<p>pub/sub 模式可以使用，你不需要知道引用。</p>

<p>下面来一个例子：实现有多个 product 组件，点击他们的时候，展示 product 的名字。</p>

<p>(我在例子中引入了之前推荐的 PubSubJS 库，如果你觉得引入代价太大，也可以手写一个简版，还是比较容易的，很好用哈，大家也可以体验，但是我还是不推荐全局广播的方式)</p>

<pre><code>// 定义一个容器
var ProductList = React.createClass({
    render: function () {
      return (
        &lt;div&gt;
          &lt;ProductSelection /&gt;
          &lt;Product name="product 1" /&gt;
          &lt;Product name="product 2" /&gt;
          &lt;Product name="product 3" /&gt;
        &lt;/div&gt;
      );
    }
});
// 用于展示点击的产品信息容器
var ProductSelection = React.createClass({
  getInitialState: function() {
    return {
      selection: 'none'
    };
  },
  componentDidMount: function () {
    this.pubsub_token = PubSub.subscribe('products', function (topic, product) {
      this.setState({
        selection: product
      });
    }.bind(this));
  },
  componentWillUnmount: function () {
    PubSub.unsubscribe(this.pubsub_token);
  },
  render: function () {
    return (
      &lt;p&gt;You have selected the product : {this.state.selection}&lt;/p&gt;
    );
  }
});

var Product = React.createClass({
  onclick: function () {
    PubSub.publish('products', this.props.name);
  },
  render: function() {
    return &lt;div onClick={this.onclick}&gt;{this.props.name}&lt;/div&gt;;
  }
});
</code></pre>

<p><img src="/images/react/demo5.gif" alt="运行结果" /></p>

<h3>ES6: yield and js-csp</h3>

<p>ES6 中有一种传递信息的方式，使用生成函数(generators)和 yield 关键字。可以看一下 <a href="https://github.com/ubolonton/js-csp">https://github.com/ubolonton/js-csp</a></p>

<p>（这里我写一个简单的 DEMO 介绍一下这种新的传递方式，其实大同小异）</p>

<pre><code>function* list() {
    for(var i = 0; i &lt; arguments.length; i++) {
        yield arguments[i];
    }
    return "done.";
}

var o = list(1, 2, 3);

var cur = o.next;
while(!cur.done) {
    cur = o.next();
    console.log(cur);
}
</code></pre>

<p>以上例子来自于屈屈的一篇博客：<a href="http://imququ.com/post/generator-function-in-es6.html">ES6 中的生成器函数介绍</a> 屈屈是一个大牛，大家可以经常关注他的博客。</p>

<p>通常来说，你有一个队列，对象在里面都能找到一个引用，在定义的时候锁住，当发生的时候，立即打开锁执行。js-csp 是一种解决办法，也许以后还会有其他解决办法。</p>

<h3>结尾</h3>

<p>在实际应用中，按照实际要解决的需求选择解决办法。对于小应用程序，你可以使用 props 和回调的方法进行组件之间的数据交换。你可以通过 pub/sub 模式，以避免污染你的组件。在这里，我们不是在谈论数据，只是组件。对于数据的请求、数据的变化等场景，可以使用 Facebook 的 Flux、Relay、GraphQL 来处理，都非常的好用。</p>

<blockquote><p>文中的每一个例子我都验证过了，主要使用最原始的引入文件方式，创建服务使用的 http-server 包，大家也可以尝试自己来一次。</p></blockquote>

<p>译：<a href="http://ctheu.com/2015/02/12/how-to-communicate-between-react-components/#child_to_parent">英文原版</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">小撸</span></span>

      




<time class='entry-date' datetime='2015-07-19T00:00:00+08:00'><span class='date'>2015 年7 月19 日</span> <span class='time'>12:00 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://fegg.github.io/blog/20150719/react-component-communicate/" data-via="lulin666000" data-counturl="http://fegg.github.io/blog/20150719/react-component-communicate/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/20150709/Hello-Angular2/" title="Previous Post: Hello Angular2">&laquo; Hello Angular2</a>
      
      
        <a class="basic-alignment right" href="/blog/20150726/induction-react-component-dev/" title="Next Post: React 组件开发入门">React 组件开发入门 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20160517/redux-can-do/">Redux 能做什么？</a>
      </li>
    
      <li class="post">
        <a href="/blog/20160110/checkbox-anim/">一个好玩的 CSS 技术 CheckBox</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151216/hi-vue/">乱玩 Vue Todo</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151024/postcss-introduce/">PostCSS是个什么鬼东西？</a>
      </li>
    
      <li class="post">
        <a href="/blog/20151009/pro-js-2/">JavaScript的特性、函数、对象</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/fegg">@fegg</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'fegg',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 小撸 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
