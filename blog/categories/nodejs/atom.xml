<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nodejs | 小撸]]></title>
  <link href="http://fegg.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://fegg.github.io/"/>
  <updated>2016-07-24T17:52:56+08:00</updated>
  <id>http://fegg.github.io/</id>
  <author>
    <name><![CDATA[小撸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一步步学习ThinkJS（一）]]></title>
    <link href="http://fegg.github.io/blog/20141127/one-step-study-thinkjs1/"/>
    <updated>2014-11-27T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20141127/one-step-study-thinkjs1</id>
    <content type="html"><![CDATA[<h3 id="section">八卦</h3>

<p>在2014年9月22日的时候，ThinkJS 1.0开了一个简单的发布会，去抢啦几块蛋糕来吃~现在还记得蛋糕超级好吃！- 0 - 不过成银这套NodeJS框架真心很好用（可能是以前用J2EE的框架用得比较多，所以感觉MVC这类框架比较好理解，不过文章写得很详细，相信看完就能上手），也很强大，上手极快，我相信它将越来越火！下面我们来入个门哈，如果有写得不对的可以直接指出来，使自己进步 ^o^</p>

<p>如果要看官方文档资料，可以进入<a href="http://thinkjs.org/doc.html">ThinkJS官网地址</a></p>

<p>当然，也少不了手把手视频教程，大家可以去看哦！</p>

<p><a href="http://thinkjs.org/video.html">ThinkJS视频教程</a></p>

<h3 id="thinkjs">一、安装ThinkJS</h3>

<p>首先得知道ThinkJS是基于NodeJS来玩的MVC框架，所以第一步是先安装NodeJS，直接去官网下载一个pkg的安装包即可。</p>

<p><a href="http://nodejs.org/">NodeJS官网</a></p>

<p>如果你翻墙不了，可以到我分享的360云盘去下载：</p>

<p><a href="http://yunpan.cn/cAtcbhmeYZKss">NodeJS 360云盘地址</a>  （提取码：47a2）</p>

<!-- more -->

<p>好啦，准备工作就这些，这里我使用的是Unix环境，如果你是Windows的话，可以去查其他教程，但是建议玩NodeJS就不要在Windows上玩了。下面我的命令基本都是使用sudo权限，看过我文章的都知道，是为了不给自己找不必要的麻烦。</p>

<p><code>bash
sudo npm install -g thinkjs-cmd
</code></p>

<p>暂时还没遇到过下载不下来的情况，所以不需要用镜像了。下载完成后你会发现有一些依赖的库都顺带下载下来了。</p>

<p>我们可以先看一下ThinkJS依赖的NodeJS版本、包的源文件地址、依赖信息</p>

<p><code>bash
npm view thinkjs engines
npm view thinkjs repository.url
npm view thinkjs dependencies
</code></p>

<p>这里就不贴结果了，可以运行试试，主要是依赖的版本和依赖信息，可以看出ThinkJS能够使用其他什么技术进行开发（默认的模板引擎：ejs，NodeJS默认的就是这玩意；依赖ES6-Promise，可以让你感受不一样写JS的赶脚；还有WebSocket等实用接口）。</p>

<p>接来下我们先创建一个ThinkJS项目，按步骤来就行了，so easy!</p>

<p><code>bash
//进入一个ROOT目录
cd ~/Documents
//创建项目根目录文件以及进入该文件
mkdir thinkjs &amp;&amp; cd thinkjs
//快速创建
thinkjs .
</code></p>

<p>这样子就可以了，很方便吧，最后会默认在终端提示：</p>

<p><code>bash
Application create finished
</code></p>

<p>并且打开默认浏览器，在浏览器中显示：</p>

<p><code>bash
hello, thinkjs!
</code></p>

<p>在浏览器地址栏，可以看出默认的端口是：<strong>8360</strong></p>

<p>现在我们就可以开始撸码啦，那么我们先来看看生成的ThinkJS的一个项目长什么样子吧。</p>

<h3 id="section-1">二、项目目录简介</h3>

<p>大家看了目录不要失望，对，就长下面那个戳样，不过真心是很好用的一个框架！</p>

<p><img src="http://p4.qhimg.com/t019f1e0f87d83b3d83.png" alt="ThinkJS默认目录结构" /></p>

<p>主要说一下App、www这两个目录，因为入门的话，完全就够了，不要搞得太复杂，以至于学不下去。</p>

<p><strong>- App</strong></p>

<p>这个文件里面的就是MVC设计模式的核心，你可以将APP/Lib目录展开，最后在APP目录下可以发现三个目录：</p>

<ul>
  <li>Model （数据模型）</li>
  <li>Controller （控制类）</li>
  <li>View （界面类）</li>
</ul>

<p>所以分工相当的明确。</p>

<p>MVC设计模式解决的问题之一是：M与V的解耦。C负责数据与界面数据的同步。但是这样说还是很模糊吧，如果学过J2EE的Struts2、SSH或者Spring MVC会特别熟悉这一块，所以我们来通俗的说一下。</p>

<p>比如我们做项目的流程就是：</p>

<blockquote>
  <p>【创建数据库、表】-&gt;【取出数据】-&gt;【界面获取数据展现】</p>
</blockquote>

<p><img src="http://p6.qhimg.com/t019347a6bf1453c4c0.png" alt="流程" /></p>

<p>这里的流程简图为了更直观理解，所以倒放了，实际操作是逆向的。</p>

<p>现在我们在【取出数据】与【界面展现】中间隔离一下，将对数据的逻辑操作独立出来，形成一层【控制层】。</p>

<blockquote>
  <p>【控制层】就通过调用【数据模型】获取数据，来与【界面展现】进行交互，并且控制用户的输入，最后向【数据模型】层发送数据。这样就做到了【数据模型】层不直接与【界面展现】层打交道，达到解耦的目的。</p>
</blockquote>

<p><img src="http://p3.qhimg.com/t0139892a3cd097f2ec.png" alt="改进为MVC模型" /></p>

<p>现在有这样一个需求：我们要从数据库的“think_user”表中，读取数据，其中数据包括：用户名、用户头像、用户博客链接3个数据，最后展现到界面中，形成如下图所示的样子：</p>

<p><img src="http://p2.qhimg.com/t01132f641e8b05fdef.png" alt="效果图" /></p>

<p>很简单的需求，是吧！就是一个查询，再遍历展示的操作，不过只要你会了这一步，CRUD你就可以轻松掌握了。</p>

<p>接下来我们将按照：创建数据库和表 -&gt; 编写数据模型 -&gt; 编写控制层 -&gt; 编写界面层的顺序来玩一玩ThinkJS。</p>

<h3 id="section-2">三、创建数据库和表</h3>

<p>之前的一篇文章写过<a href="http://blog.51yuekan.com/2014/11/26/2014-11-26-Mac%20OS%20X%2010.9%E9%85%8D%E7%BD%AEAMP%E7%8E%AF%E5%A2%83/">Max OS X上搭建MySQL</a>，这里我就直接开始了。</p>

<ul>
  <li>创建数据库、创建think_user表</li>
</ul>

<p>``` sql
create database blog;</p>

<p>use blog;</p>

<p>create table think_user (
	userid varchar(20) not null,
	username varchar(50) not null,
	passwd varchar(100) not null,
	photo varchar(255) not null,
	blogurl varchar(255) default null,
	primary key(userid)
);
```</p>

<ul>
  <li>按照自己的需要添加一些数据，最好在创建库的时候使用UTF8编码和字符集。</li>
</ul>

<p>最后搞出来的样子如下图所示：</p>

<p><img src="http://p5.qhimg.com/t01be1402d6468f06ad.png" alt="数据情况" /></p>

<p>接下来我们需要找到创建的ThinkJS项目的对应数据库映射配置文件：</p>

<p><code>bash
App/Conf/config.js
</code></p>

<p>这个文件里面配置了一些MySQL的参数，官方解释得很清晰，这里面也可以看出我们为什么表要以think_为前缀的原因。我的配置如下：</p>

<p><code>javascript
module.exports = {
	//配置项: 配置值
	port: 8360, //监听的端口
	db_type: 'mysql', // 数据库类型
	db_host: '127.0.0.1', // 服务器地址
	db_port: '', // 端口
	db_name: 'blog', // 数据库名
	db_user: 'root', // 用户名
	db_pwd: 'lulin', // 密码，= =明文的
	db_prefix: 'think_', // 数据库表前缀
};
</code></p>

<p>这样我们的配置工作就弄完啦，可以开始撸码啦。先查询出全部的user信息。</p>

<h3 id="section-3">四、编写数据模型</h3>

<p>我们需要在“Lib/Model”目录下面建立一个文件”UserModel.js”，详情如下图：</p>

<p><img src="http://p3.qhimg.com/t01a7940516c348787a.png" alt="目录结构" /></p>

<p>这里的名字是有讲究的，与数据库中的think_user表是对应的，默认除去think_前缀。不推荐使用奇葩写法来映射，虽然官方提供了自己手动做一些解析，但是要从最开始就养成好习惯，好处以后会慢慢体现出来。</p>

<p>好，接下来我们看看查询think_user表的数据代码是怎么样子的：</p>

<p>``` javascript
module.exports = Model(function () {
	return {
		getUserList: function () {
			var self = this;</p>

<pre><code>		return self.select().then(function(data) {
			return data;
		});
	}
}; }); ```
</code></pre>

<p>是不是感觉简单爆啦！对，用起来就是这般酸爽！官方还提供了更多的方式，现在可以看看<a href="http://thinkjs.org/doc/model.html#模型定义">官网</a>，留个印象。</p>

<p>这样子我们就可以通过调用getUserList()方法来得到数据对象，现在我们在控制层中，将数据传到界面的手上，途中可以做一些处理，好吧，来看看控制层怎么搞。</p>

<h3 id="section-4">五、编写控制层</h3>

<p>如上图，Controller层的Home目录默认有两个文件，这里成银使用的继承的方式来做，这样对于中小型开发是很有力的，当然结构控制得好，大型开发也同样给力，毫不逊色。IndexController继承于BaseController，BaseController里面基本就初始化，这里我们只需要修改IndexController来实现我们的需求。</p>

<p>``` javascript
module.exports = Controller(“Home/BaseController”, function(){
	“use strict”;</p>

<pre><code>return {
	indexAction: function(){
		var self = this;
	
		var userModel = D('user');
		var userList = userModel.getUserList();
	
		//将数据库中的值传入userList变量中
		self.assign('userList', userList);
		//渲染到页面上，默认会渲染index_index.html页面
		self.display();
	}
}; }); ```
</code></pre>

<p>代码也很好写吧，接下来就是写页面了，再将数据填充进去就完成需求了。</p>

<h3 id="section-5">六、编写界面层</h3>

<p>这里就跟ThinkJS没什么关系了，单纯的就是写页面，最后使用ejs填充数据。目录结构如下图，分别是HTML、CSS、JS代码的目录。</p>

<p><img src="http://p9.qhimg.com/t014fe628ee5bda311d.png" alt="目录结构" /></p>

<p>DOM结构（CSS代码附在文章末尾处了）</p>

<p><img src="http://p4.qhimg.com/t0133963df1689d6611.png" alt="DOM结构" /></p>

<p>哎，hexo编译的时候报错，所以只好截图一张了。</p>

<blockquote>
  <p>不过要注意，引入的CSS和JS文件的相对路径是”resource/xxx/xxx”这样的，也就是说www目录是网站的ROOT目录。</p>
</blockquote>

<p>在这里我们就可以启动ThinkJS项目了，入口文件为：</p>

<p><code>bash
www/index.js
</code></p>

<p>所以进入www目录，使用下面的经典命令就可以在网页 <a href="http://127.0.0.1:8360">http://127.0.0.1:8360</a> 中浏览效果了，本例子中得效果就如最开始的那张图一模一样。</p>

<p><code>bash
node index.js
</code></p>

<p>如果你还觉得不过瘾，你现在可以再写一个后台管理，实现数据的可视化添加、编辑、删除功能，这样一个简单的系统就已经起来了！很简单是吧，完全感受不到框架的存在，感受不到它的存在就对了，这样就是一个好框架了！^0^</p>

<p>附：本例子中的CSS代码</p>

<p><code>css
.main {
	min-height: 400px;
	_height: 400px;
	background: #ededed;
}
.content {
	text-align: center;
}
.items {
	display: inline-block;
	margin-left: -20px;
	*display: inline;
	*zoom: 1;
}
.item {
	float: left;
	width: 160px;
	margin-left: 20px;
}
.item-link {
	display: block;
	width: 100%;
	height: 100%;
	text-decoration: none;
}
.item-photo {
	display: block;
	width: 150px;
	height: 150px;
	border: 3px solid #f5f5f5;
	border-radius: 50%;
}
.item-username {
	display: block;
	width: 100%;
	height: 40px;
	line-height: 40px;
	font-size: 18px;
	text-align: center;
	color: #222;
}
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强大的Makefile]]></title>
    <link href="http://fegg.github.io/blog/20140802/power-by-makefile/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20140802/power-by-makefile</id>
    <content type="html"><![CDATA[<h3 id="make-">一、make 规则</h3>

<pre><code>Target: Dependencies
	&lt;TAB&gt;Commands
</code></pre>

<p>例子：</p>

<pre><code>main.o: main.c common.c common.h
	gcc -c main.c
</code></pre>

<h3 id="makefile-">二、建立 Makefile (这里不带后缀名，并且根据习惯首字母大写)</h3>

<p>输入以下内容：</p>

<pre><code>clean: 
	@echo hello
	echo hello
</code></pre>

<p>ps:
在终端输入命令：make clean 执行（但是需要在Makefile的同级目录）
如果是在windows环境下，你也可以使用nmake进行测试，但是我相信在windows就不用这种方式了。
1. clean: 定义执行的make的命令。
2. @echo: 直接输出“hello”字符串，但是不打印代码。
3. echo: 输出“hello”字符串，并且打印代码。</p>

<p>执行结果如下：</p>

<!--more-->

<p><img src="/images/post/make1.png" alt="Mou icon" /></p>

<h3 id="makefile-c">三、通过 Makefile 去编译并且执行C语言代码</h3>

<p>(1) 首先创建main.c源代码文件，这个不难。</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
	printf("-----------\n");
	printf("hello\n");
	printf("-----------\n");
}
</code></pre>

<p>(2) 创建我们需要的Makefile文件，内容如下。</p>

<pre><code>targets = main

$(targets): main.c 
	gcc main.c -o main.o
	./main.o

clean:
	rm *.o
</code></pre>

<p>ps: 这里出现了新语法：变量定义
变量的声明–&gt; targets = main.o
引用变量–&gt; $(targets)
等价于：</p>

<pre><code>main: main.c 
	gcc main.c -o main.o
	./main.o

clean:
	rm *.o
</code></pre>

<p>(3) 执行效果。</p>

<p><img src="/images/post/make2.png" alt="Mou icon" /></p>

<p>ps: 这里执行了make &amp;&amp; make clean（等价于：make main &amp;&amp; make clean）
1. make不带参数，默认执行第一条命令。
2. &amp;&amp;：左边命令执行成功，就执行右边的命令（和程序中的&amp;&amp;是一样的效果）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js Npm 详解（2）]]></title>
    <link href="http://fegg.github.io/blog/20140802/node-npm-detail-2/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20140802/node-npm-detail-2</id>
    <content type="html"><![CDATA[<p>安装Node和npm前半部分的配置可以参考之前我的两篇文章：</p>

<ol>
  <li><a href="http://blog.51yuekan.com/2014/10/08/2014-08-02-hello-nodejs/">Hello Node</a></li>
  <li><a href="http://blog.51yuekan.com/2014/10/08/2014-08-02-node-npm-detail-1/">Node npm 详解（1）</a></li>
</ol>

<h3 id="section">四、本地模式和全局模式</h3>

<p>如果你了解环境变量里面的，用户变量和系统变量。可以做一个类比进行理解。当然，windows上面的环境变量概念比较好理解。</p>

<!-- more -->

<h4 id="section-1">1. 本地模式</h4>

<p>本地模式下安装包的特点</p>

<ul>
  <li>不会写入PATH变量（也就是环境变量，无法在全局引用该安装包，不能在终端直接使用）</li>
  <li>能够在不同的node_modules目录，安装不同版本的安装包</li>
  <li>能够通过require()来引入安装包</li>
</ul>

<p>使用“npm install <pkg>[@<version>]”安装的包，默认会安装在当前目录的“node_modules”目录下（如果没有该目录，在执行命令的时候，会自动帮你创建）。</version></pkg></p>

<pre><code>//专业的写法
./node_modules
</code></pre>

<p>（1）默认采用本地模式安装</p>

<pre><code>npm install &lt;pkg&gt;
</code></pre>

<p>（2）信息写入package.json文件</p>

<pre><code>npm install &lt;pkg&gt; --save
</code></pre>

<p>这个命令在安装包的同时，将信息写入package.json。</p>

<blockquote>
  <p>@version表示指定安装包的版本号，是可选项目，默认安装最新版本。</p>
</blockquote>

<blockquote>
  <p>项目路径中如果有package.json文件，使用npm install方法就可以根据dependencies配置安装所有的依赖包。</p>
</blockquote>

<blockquote>
  <p>如果这样配置，当代码提交到github时，就不用提交node_modules这个文件夹。</p>
</blockquote>

<h4 id="section-2">2. 全局模式</h4>

<p>全局模式安装包的特点</p>

<ul>
  <li>不需要重复安装</li>
  <li>不能使用require()引入</li>
  <li>会写入PATH，并建立软链接，使用命令行的方式使用</li>
  <li>不方便指定特定的版本运行</li>
</ul>

<p>（1）采用全局模式安装</p>

<pre><code>npm install -g &lt;pkg&gt;
</code></pre>

<p>（3）在mac中全局的目录</p>

<pre><code>//安装包所在目录
/usr/local/lib/node_modules/
//运行命令的软链接所在目录
/usr/local/bin
</code></pre>

<p>（4）查看安装包路径</p>

<pre><code>//查看当前包的安装路径
npm root
//查看全局的包的安装路径
npm root -g
</code></pre>

<p>（5）设置全局模式安装目录</p>

<pre><code>//设置后，以全局模式将会安装在此目录中，不过需要手动加入PATH，切记
npm config set prefix &lt;global dir&gt;
//设置npm缓存文件的存放路径
npm config set cache &lt;cache dir&gt;
</code></pre>

<p>（6）查看默认模式</p>

<pre><code>//默认返回：false    
$ npm get global
$ npm config get global
</code></pre>

<p>（7）设置为默认以全局模式安装，就不用每次加”-g”参数啦。</p>

<pre><code>$ npm set global=true
$ npm config set global=true
</code></pre>

<blockquote>
  <p>npm set / npm config set与npm get / npm config get的区别和联系单独写吧。其实不难，只是需要实验才能得出结果，这里区别很细节。</p>
</blockquote>

<blockquote>
  <p>准备把文章拆分成几篇，写得详细了一点，这里写的话篇幅就太长了。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js Npm 详解（1）]]></title>
    <link href="http://fegg.github.io/blog/20140802/node-npm-detail-1/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20140802/node-npm-detail-1</id>
    <content type="html"><![CDATA[<h3 id="npm">一、npm简介</h3>

<p>安装npm请阅读我之前的文章<a href="http://blog.51yuekan.com/2014/10/08/2014-08-02-hello-nodejs/">Hello Node</a>中npm安装那一部分，不过只介绍了linux平台，如果是其它平台，有<a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config">前辈</a>写了更加详细的介绍。</p>

<p>npm的全称：Node Package Manager.</p>

<h4 id="section">（1）通俗的理解</h4>

<p>其实从字面意思就可以理解这个产品有什么作用翻译为“Node包管理器”。对，就是Node的包的一个管理工具，目前我尝试的有</p>

<ol>
  <li>下载并安装包（npm install [pkg]）</li>
  <li>升级安装包（npm update [pkg]）</li>
  <li>卸载安装包（npm uninstall/rm [pkg]），可以指定卸载包的版本号
…</li>
</ol>

<p>其实这些命令很简单，常用的必须记住，不常用的查询即可，这才是比较好的学习知识方式。</p>

<!-- more -->

<p>在终端输入：</p>

<pre><code>//查看npm拥有的全部命令
$ npm --help
$ npm help
//查看某一个npm命令的详细用法
$ npm &lt;command&gt; --help
$ npm help &lt;command&gt;
</code></pre>

<h4 id="section-1">（2）专业的解释</h4>

<p>npm（Node Package Manager）是Node.js下的主流套件管理程式。它在Node.js v0.6.x版本之后，内建于Node系统。通过npm可以协助开发者安装、卸载、删除、更新Node.js套件，并且可以通过npm发布自己的插件。</p>

<h3 id="section-2">二、类似的产品</h3>

<p>其实学习一个产品，可以联系其它产品，能够更好的理解现在手头的产品。第一次学习npm我的第一反应就是，很像linux/mac平台的很多软件，依赖管理的方式可以参考maven…当然相似性可以随便联想。</p>

<p>接下来，举几个例子吧，当然详细了解可以查baidu &amp;&amp; google。</p>

<ol>
  <li>gem</li>
  <li>PyPL</li>
  <li>pear</li>
  <li>macPort</li>
  <li>Homebrew</li>
  <li>rem</li>
  <li>apt-get</li>
  <li>yum
…</li>
</ol>

<p>是不是很多都很熟悉？这样对于npm的认识就不用局限于概念啦。</p>

<h3 id="npm-1">三、npm基础功能</h3>

<h4 id="npmrc">（1）npmrc文件介绍</h4>

<p>首先介绍一下npmrc文件，这个文件是npm包管理器的配置文件。</p>

<p>与npmrc相关的三个文件：</p>

<ol>
  <li>用户配置文件：~/.npmrc</li>
  <li>全局配置文件：$PREFIX/npmrc</li>
  <li>npm内部配置文件：安装npm的目录下</li>
</ol>

<p>下面仔细看一下npm config的配置。</p>

<h4 id="npm6">（2）npm获取配置的6种方式（优先级从高到低）：</h4>

<p>1.命令行参数</p>

<pre><code>$ --proxy http://&lt;server&gt;:&lt;port&gt;
</code></pre>

<p>2.环境变量</p>

<p>以”npm_config_“为前缀的环境变量将会被认为是npm的配置属性。
像Maven镜像的概念，方便通信吧。</p>

<pre><code>$ npm_config_proxy=http://&lt;server&gt;:&lt;port&gt;
</code></pre>

<p>3.用户配置文件</p>

<pre><code>//查看文件路径
$ npm config get userconfig

//mac系统默认路径
$HOME/.npmrc
</code></pre>

<p>4.全局配置文件</p>

<pre><code>//查看文件路径
$ npm config get globalconfig

//mac系统默认路径
/usr/local/etc/npmrc
</code></pre>

<blockquote>
  <p>3，4中输入终端的效果如图：</p>
</blockquote>

<p><img src="/images/post/node-npm/node-npm-3-and-4.png" alt="3，4在终端的结果" /></p>

<p>5.内置配置文件</p>

<p>安装npm的目录下的npmrc文件。</p>

<p>6.默认配置</p>

<p>如果前5条均未设置，npm会使用默认配置参数。</p>

<h4 id="npm-install-pkg-name">（4）npm install <pkg name=""></pkg></h4>

<p>“安装指定包”：这个命令不难，但是也有需要注意的地方，就是安装的模式有两种，在后面会单独讲解。</p>

<blockquote>
  <p>如果不知道包的具体名称，可以在<a href="http://search.npmjs.org">http://search.npmjs.org</a>上进行搜索。</p>
</blockquote>

<h4 id="npm-uninstall-pkg-name">（5）npm uninstall <pkg name=""></pkg></h4>

<p>“卸载指定包”：在help的时候，会给你推荐npm rm <pkg name="">这个命令，uninstall会卸载掉包的依赖，rm。</pkg></p>

<h4 id="npm-ls">（6）npm ls</h4>

<p>查看安装的包清单，其实和linux的ls命令很像，可以跟很多参数，详情可以使用</p>

<pre><code>$ npm help ls
</code></pre>

<h4 id="npm-search-pkg-name">（7）npm search <pkg name=""></pkg></h4>

<p>搜索包的详细信息，比如我们搜索express试试。第一次搜索，会提示建立索引，需要耐心等待片刻，大家测试的时候不要就关掉啦终端。</p>

<pre><code>npm WARN Building the local index for the first time, please be patient
</code></pre>

<p><img src="/images/post/node-npm/node-npm-search.png" alt="express包的搜索结果" /></p>

<p>其实看上去复杂，只是东西有点大，不过主要包含以下6个部分：</p>

<ol>
  <li>名称</li>
  <li>描述</li>
  <li>作者</li>
  <li>发布时间</li>
  <li>发布版本号</li>
  <li>关键字</li>
</ol>

<h4 id="npm-update-pkg-name">（8）npm update <pkg name=""></pkg></h4>

<p>更新安装的包</p>

<p>更多API可以查看官网：<a href="https://npmjs.org/doc/">https://npmjs.org/doc/</a></p>

<h3 id="section-3">四、版本号的知识。</h3>

<p>在node.js中的package.json配置文件中，我们需要配置版本号，比如0.1.2</p>

<p>第一位数字：主版本号</p>

<p>第二位数字：子版本号</p>

<p>第三位数字：补丁版本号</p>

<p>找到一个不错的介绍软件项目版本号的文章</p>

<p><a href="http://www.cnblogs.com/sdjxcolin/archive/2007/07/02/803376.html">软件项目版本号的命名规则及格式</a></p>

<p>为什么要解释这个呢？肯定是有用，因为npm安装的时候是可以选择版本号的，有点理解会比较好吧，至少我是这么认为的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Node.js]]></title>
    <link href="http://fegg.github.io/blog/20140802/hello-nodejs/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20140802/hello-nodejs</id>
    <content type="html"><![CDATA[<h3 id="section">一、前言</h3>

<p>很久之前就想系统的学习nodejs技术了，但是由于很多事情，忙不太过来，今天晚上下定决心要入门这门技术，所以一口气看完了《Node.js开发指南》和《Node.js中文文档》，总算是真正入门了，接下来就总结一部分，剩下的只有明天再总结了。</p>

<h3 id="nodejs">二、Node.js简介</h3>

<p>一句话简单说明一下node.js是什么东西。</p>

<blockquote>
  <p>Node.js 是一个让 JavaScript 运行在服务端的开发平台。</p>
</blockquote>

<h3 id="nodejs-1">三、Node.js的安装</h3>

<p>学习了Node.js，觉得如果在window下学习这门技术的话还太成熟，第三方的支持不太好，所以只介绍linux或者mac上面的安装。node.js在window上面的安装直接下载安装包，一直下一步就可以装好，环境变量也会自动配置好，npm（node package manage）在新版本也会相应的装上。</p>

<p>对于mac环境安装也比较简单，介绍两种安装方式。</p>

<!-- more -->

<p>1.homebrew（注意一直使用admin权限吧，大多都是权限文件夹，可以在终端开始使用sudo -s命令来一直使用admin权限）</p>

<pre><code>$ sudo brew install node
</code></pre>

<p>这样下载完了就算安装上了，我们可以来检测一下你的安装（软件配置必须要的步骤）。</p>

<pre><code># 查看node版本号
$ node -v 
# 查看npm版本号和清单
$ npm -v &amp;&amp; npm list
</code></pre>

<p>如果npm没有安装上，那么可以使用以下命令安装。</p>

<pre><code>$ sudo curl http://npmjs.org/install.sh | sh
</code></pre>

<p>2.使用源码编译的方式（其实有方便的尽量就避免麻烦的，嘿嘿）</p>

<blockquote>
  <p>下载地址：http://nodejs.org</p>
</blockquote>

<p>执行典型的安装命令即可（注意到/bin目录，或者有configure文件的目录）。</p>

<pre><code>$ ./configure &amp;&amp; make &amp;&amp; sudo make install
</code></pre>

<h3 id="nodejsn">四、Node.js的多版本管理器n</h3>
<blockquote>
  <p>下载地址：https://github.com/visionmedia/n</p>
</blockquote>

<p>如上执行源码安装命令即可。</p>

<p>当然，如果你安装了npm，就有更方便的方式，这也是很迷人的地方。</p>

<pre><code>$ sudo npm install -g n
</code></pre>

<p>接下来检查一下安装情况。</p>

<pre><code>$ n --version
</code></pre>

<p>这样就可以使用自由切换使用node的版本了。用如下命令安装指定版本的node。</p>

<pre><code>$ n version
</code></pre>

<p>下载后，会默认下载到：/usr/local/n/versions/目录</p>

<p>如果你安装后，再使用”$ n version”命令就是指定使用的默认版本号，也可以使用“$ n use version xxx.js”来暂时使用某个node版本执行xxx.js文件。</p>

<h3 id="hello-nodejs">五、万事具备，只欠Hello Node.js</h3>

<p>每个语言入门都可以写一个hello xxx，示好。</p>

<p>在node中，这个很简单，只需要进入REPL模式，暂时不要管这个模式是什么，我们先使用。这个用截图来直观说明一下。</p>

<p>进入REPL模式的命令：</p>

<pre><code>$ node
</code></pre>

<p>接下来直接输入：</p>

<pre><code>console.log('hello node.js!');
</code></pre>

<p>就可以在终端打印出：</p>

<pre><code>&gt;hello node.js!
&gt;undefined
</code></pre>

<p>写过js的应该对最后会输出undefined并不吃惊，先可以不管。</p>

<p><img src="/images/post/hello-node.js.png" alt="Mou icon" /></p>

<p>下面解释一下REPL模式：</p>

<p>其实这个模式不用解释，经过上面的例子应该就有直观的认识啦，类似mysql、python等的shell交互的方式，可以让你输入马上就得到反馈，输出结果到屏幕上面。在node中可以连续按两次ctrl+c退出（但是python要使用exit()函数，很不舒服）。</p>

<p>上面是一种最简单的方式，还是介绍一种正规的方式吧，既然是js的运行平台，我们就写一个js文件：hello.js，内容很简单，如下：</p>

<pre><code>console.log('hello node.js!');
console.log('%d\n', 60);
</code></pre>

<p>在终端执行（注意要进入hello.js所在目录哦）：</p>

<pre><code>$ node hello.js
</code></pre>

<p>就可以在终端直接输出结果了。</p>

<blockquote>
  <p>为什么我加入了“console.log(‘%d\n’, 60);”这一句呢？那是因为这可以测试出其实可以用c语言printf的方式来写console.log()。</p>
</blockquote>

<h3 id="nodejs-2">六、Node.js终于来到了浏览器</h3>

<p>前面的例子都是在控制台里面的，没什么意思，我们接下来写一个我们典型的B/S访问的方式。当然这就离不开HTTP了，查看了一下node的源码，新版本默认是http 1.1，支持http和https这两种协议。</p>

<p>我们先建一个http.js文件，里面的内容对于后台的开发人员就很熟悉了。</p>

<p><code>javascript
var http = require('http');
http.createServer(function(req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write('&lt;h1&gt;Node.js&lt;/h1&gt;');
    res.end('&lt;p&gt;Hello Node.js&lt;/p&gt;');
}).listen(8888);
console.log("HTTP server is listening at port 8888.");
</code></p>

<p>以上代码监听的port：8888，这其实就是建立了一个request，我们在浏览器地址栏中输入：http://localhost:8888/ 即可以访问我们打印的内容。</p>

<p>我们先在终端运行后台服务：</p>

<pre><code>$ node http.js
</code></pre>

<p><img src="/images/post/http-node.js.png" alt="Mou icon" /></p>

<p>我们来分析一下这个简单的程序，其实从require的加载方式我们并不陌生，这是现在模块加载在前端普遍使用的函数名，那么为什么我们的js代码就能够这样来请求和访问呢？我们来简单的看看源码的解析。</p>

<h4 id="httpjs">1. 首先我们先看看源码的http.js文件。</h4>

<p><code>javascript
var Server = exports.Server = server.Server;
function createServer() { return new Server(requestListener) };
</code></p>

<p>在这个文件中，我们知道createServer()方法其实返回的就是Server类，这个类是由server这个实例来的。</p>

<h4 id="httpserverjs">2. 接下来我们再追踪一下_http_server.js文件。</h4>

<p>这个要问怎么找到这些文件的，其实是凭直觉和猜测，再加上模块化的调试方法，可以找到http.js文件的加载模块，就可以找到相应的文件了。</p>

<p><code>javascript
function requestListener() {};
function connectionListener(socket) {}
Server.prototype.setTimeout = function(msecs, callback) {};
</code></p>

<p>再这个文件中，我们可以看出和Socket原理差不多，使用定时器来实现端口的监听，但是在源码中可以找到主定时器，这个概念来源于游戏开发，在全局设置定时器，这样大大提升了性能，不得不佩服作者的才能。</p>

<h4 id="nodeccnode">3. 那么我们node底层是c/c++来实现的，我们可以追踪一下node的启动。</h4>

<p>我们先找到c语言的main文件，后来发现好多node_开头的，大楷就是系统和行一点的文件了，在node_main.cc文件中发现了：node::Start(argc, argv);函数，但是找不到具体实现，那么就肯定是在依赖文件中，通过头文件的声明，找到了，其实实现位于node.cc文件。</p>

<h4 id="nodeccnode-1">4. node.cc文件来看node启动流程。</h4>

<p>函数大致的执行顺序为：</p>

<p><code>c
int Start(int argc, char** argv)
V8::Initialize();
    CreateEnvironment() //创建当前环境
    SetupProcessObject() //启动当前环境的进程
    Load() //加载当前环境
    context() //引用上下文
    uv_run //开始异步事件运行
    RunAtExit //删除异步事件链表
</code></p>

<p>上面可以看出其实就是通过一系列初始化，最后达到平台的建立。</p>

<h4 id="module">5. module的加载实质</h4>

<p>其实我们经过上面的分析，我们大致知道的node的构成，那么我们能够在node.js（猜想：这个js文件是c和js沟通的桥梁）中，发现传入了process对象。源码结构如下：</p>

<p><code>javascript
(function(process) {});
//本地模块的加载接口
NativeModule.require();
</code></p>

<p>我们来看一看根据process来绑定c语言的模块。</p>

<p><code>javascript
var HTTPParser = process.binding('http_parser').HTTPParser;
</code></p>

<p>是不是就很清晰啦，接下来我们看看模块是怎么注册的。</p>

<p><code>c
//现在产生的插件会放置在node_module文件夹下应该很清晰了
//定义了一个指针结构
node_module_struct* mod
//注册自己的模块
mod-&gt;register_func(Handle&lt;Object&gt; target) 
//为注册的模块设置一个上下文
mod-&gt;register_context_func 
//最后加载到模块缓存，这里也是实现延迟加载的本质
cache-&gt;Set(module, exports)
</code></p>

<p>在模块注册后，还需要做一些准备工作才能够真正的加载到我们的js文件。</p>

<p><code>c
//node.cc文件中执行绑定
static void Binding(const FunctionCallbackInfo&lt;Value&gt;&amp; args);
//node_javascript.cc文件中会定义你的js
void DefineJavaScript(Handle&lt;Object&gt; target);
</code></p>

<h4 id="modulejsjs">6. 在module.js文件中，得到真正的js文件的加载，平台调用。</h4>

<p>在这里作者的module数据结构设置得比较简单，抛去其它得留下结构如下：</p>

<p><code>javascript
module: {
    id: '',
    parent: [],
    export: {},
    filename,
    children: []
}
</code></p>

<p>这样我们这个http程序就能够很好得解释啦。其实知道了原理后面得知识就是看看api和写法了。太晚啦，睡觉觉啦 =_=…后续…</p>

]]></content>
  </entry>
  
</feed>
