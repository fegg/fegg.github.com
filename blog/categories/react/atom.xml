<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React | 小撸]]></title>
  <link href="http://fegg.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://fegg.github.io/"/>
  <updated>2016-07-16T23:51:08+08:00</updated>
  <id>http://fegg.github.io/</id>
  <author>
    <name><![CDATA[小撸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React 的一些说词]]></title>
    <link href="http://fegg.github.io/blog/20160716/pro-react-get-started/"/>
    <updated>2016-07-16T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20160716/pro-react-get-started</id>
    <content type="html"><![CDATA[<p>其实很多文章都写 React 的代码，代码可能到 Github 上随意下载然后阅读理解，但是有些说词类的东西还是需要看的，这样能够更好的去理解一个东西。好吧，下面大致“翻译”了一下 《Pro React》这本书的 <strong>React‘s Benefits</strong> 的部分。^0^ 英文不太好，如果有不一样的地方能理解就好，毕竟不是专业翻译～</p>

<p>（1）让响应式的渲染变得简单</p>

<p>在以前的 Web 开发过程中，也就是在单页应用之前，在用户每一次浏览页面的时候（比如点击一个按钮），都将重新请求一次服务端，即使是页面上一个很小的状态的改变。这是一种糟糕的用户体验，但是在这种多页的情况下，开发者很容易掌控用户访问的页面。</p>

<p>在单页应用的交互中，用户是通过不断的从服务端获取新的数据，然后切换 DOM 的状态。但是随着系统的发展，Web 系统将变得越来越复杂，它将更加难以确定当前应用的状态（其实这里是指局部受影响的部分），以及很难准时的去更新当前交互中的 DOM 状态。</p>

<p>在 React 出现之前，有很多 JavaScript 的框架去解决以上说到的这个问题，然而，这些解决方案都有一些缺陷，比如系统的“可维护性”、“可扩展性”以及“性能”。（其实这里也不尽然，Angular 1.x 也是很优秀的，在此之前）</p>

<!-- more -->

<p>对比传统的数据绑定来说，响应式的去渲染更加容易（其实这里的容易是体现在开发、维护、测试的阶段上，对于用户来说，体现在性能上吧，因为用户只会感知页面和交互部分）。响应式的编程方式，能够让我们使用声明的方式去控制组件的展现和行为（这里 Vue 作者尤大大说过很多次的声明式编程和命令式编程）。在数据改变的时候，React 的渲染是针对整个接口（这里是指用户接口）的响应。</p>

<p>不过这种开发方式上，由于是每次用户接口引发的状态改变，对于 Web 性能上来说，都会触发 DOM 的重新渲染，这样的代价是很昂贵的，不可行的。React 的解决方案是：通过在内存中解决，构造一套“Virtual DOM”（虚拟节点）的概念，通过很牛逼的 Diff 算法去解决这个问题。</p>

<p>与传统的直接操作 DOM 的方式（比如：jQuery 的方式，不过我觉得只要虚拟 DOM 的标准好了后，jQuery 的方式依然很自由），在内存中操作虚拟 DOM 的性能是很高效的，当应用的状态改变过后（比如在用户的交互中，发起一个 Ajax 的请求，返回新的数据），React 能够快速的对比当前 UI 的状态数据和新的数据之间的不同点（这里说的就是 Diff 算法）然后以最小开销的方式去重新渲染真实 DOM，以上这种方式让 React 的性能很好，更新 DOM 很高效，React 应用能够达到 60fps 的运行帧率，即使是在移动端也是如此。</p>

<p>（2）纯 JavaScript 面向组件的开发模式</p>

<p>在 React 应用中，任何东西都是以组件的方式来表达，这些组件都是独立的，或者是搭积木的方式构建的组件块。开发中使用“分而治之”的方式（叶小钗前辈也说这是一个很重要的软件开发思想），去解决一些复杂问题，因为在 React 的开发方式中，很少会有特别复杂的组件（主要是指结构复杂，状态过多的组件吧，其实一个单页的解决方案要解决的问题就是上面提到的，因为都是在一次用户请求后就开始了所以的用户接口管理工作）。我们开发过程中需要能够让组件粒度保持在一个较小的状态（这样翻译主要是要避免理解成过度组件化的误区），因为组件具有可组合性，能够更容易构建更复杂、更丰富的组件以至于系统（也就是组合的软件方式，但是现在又倾向与 HOC 的开发方式，个人理解，这是一种组件进化的模式，其实从生物学到软件编程领域来说，这种方式相当不错）。</p>

<p>对于 Web 应用来说，React 组件使用纯 JavaScript 的开发模式，而不是传统的通过数据来渲染模版的方式来构建各个 UI。这样做更好的原因在于：模版是限制了你构建 UI 的模式（比如有一套自己的语法），React 也提供了模版语言能够提供的功能，但是这是使用 JavaScript 编程语言的方式来构建你的抽象以及 UI 界面。</p>

<p>除此之外，React 的组件开发模式，让 Web 开发的关注点也发生了改变，由于组件的独立性质，让一个组件就对应了一套界面逻辑（界面＋样式＋逻辑），而不是传统开发中的关注点在于文件的分离，比如：HTML 关注内容和结构、CSS 关注样式、JavaScript 关注行为。在之前的 Web 开发过程中，之所以要分离文件，是因为页面大多来自于展示和基本的交互。在 React 开发中，你能够更好的关注技术，而不是文件。</p>

<p>React 将展示逻辑和内容高度的耦合，然后以这种方式去封装一个组件，展示 UI，把关注点放在高复用、高扩展的组件开发上。</p>

<p>（3）轻巧、灵活的文档模型抽象</p>

<p>在 React 当中，也对一些东西做了轻量级的抽象（比如事件），这让 Web、IOS、Android 界面都能够使用相同的方式去渲染。（这里就是 React 倡导的思想）</p>

<ul>
  <li>符合标准的事件行为封装，让所有浏览器、设备都自动使用代理的方式绑定事件。</li>
  <li>React 组件能够进行服务端渲染，这有利于 SEO 和不错的性能。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redux 能做什么？]]></title>
    <link href="http://fegg.github.io/blog/20160517/redux-can-do/"/>
    <updated>2016-05-17T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20160517/redux-can-do</id>
    <content type="html"><![CDATA[<h3 id="redux-">一、我先给一个 Redux 的定义</h3>

<p><code>Redux</code> 被大家知道应该都是来自于 <code>React</code> 的出现，但是这篇文章会通过介绍一个 <code>React</code> 之外的例子，来让大家理解 <code>Redux</code> 是什么东西，到底还能够做点撒。</p>

<p>我自己的理解是：</p>

<blockquote>
  <p>Redux 是一个改变<strong>状态(state)</strong>的模型，这个模型通过一个单向操作的方式来改变<strong>状态</strong>，用数学符号的方式来理解我认为应该是：<code>y = f(x) </code>，嗯，就是一个最简单的函数模型。</p>
</blockquote>

<p>不过这样说，有些人还会不理解，毕竟以前撸代码不是这个样子的，那么我们先反向的来获取自己的理解。</p>

<p>首先，我们需要知道 Redux 有的以下几个东西：</p>

<ul>
  <li>createStore</li>
  <li>reducer</li>
  <li>dispatch</li>
</ul>

<p>我觉得需要介绍清楚 Redux ，知道这三个就行了，至于还有一些函数我觉得都是调味料，这里先不介绍。</p>

<!-- more -->

<p>好吧，现在我就把上面的数学函数模型语义的转换一下（也许不一定对，但是可能暂时这样理解，理解是一个过程）：</p>

<ol>
  <li>第一步：<code>newState = store(reducer)(state)</code></li>
  <li>第二步：<code>newState = reducer(state)</code></li>
</ol>

<p>为什么这里可能理解成两个步骤呢？那是因为我们可以从不同的层面去认识 Redux，在第一步中我的理解是store里面的东西(reducer)去改变了 state，而在第二步中，我以实际会起到作用的层面去理解，就是 reducer 去改变了 state。</p>

<p>好吧，来个对比：</p>

<p><code>javascript
y = f(x)
newState = reducer(state)
</code></p>

<p>最后我自己先得出一个结论：</p>

<p><code>javascript
f &lt;=&gt; reducer ( &lt;=&gt;: 表示等价的意思)
</code></p>

<p>好吧，废话就上面那么多了，接下来我举一个实际的例子来理一下自己对 Redux 的理解，这个例子是我在一篇文章中看到的，觉得不错。</p>

<h3 id="section">二、 先介绍一下这个例子的效果</h3>

<p><img src="/images/react/game.gif" alt="演示" /></p>

<p>这里我们要实现的效果就是：</p>

<p>点击飞机，让飞机随机移动到一个新的坐标点</p>

<p>这里我们可以理解为：新坐标[x1, y1] = f(原始坐标[x0, y0])</p>

<h3 id="section-1">三、开始撸一个实例</h3>

<p><strong>1.首先我们需要定义个 <code>f</code> 来修改坐标</strong></p>

<p><code>javascript
/**
 * reducer
 * @param state 坐标状态
 * @param action 执行的行为
*/
function coordinates(state = [1, 1], action) {
	switch (action.type) {
		case CLICK:
			return [
				state[0] + 40 * Math.random(),
				state[1] + 40 * Math.random()
			]
		default:
			return state;
	}
}
</code></p>

<p>这个函数主要就是使初始坐标 <strong>[1, 1] =&gt; [1 + random, 1 + random]</strong> 这样返回一个全新的数组，这个全新的数组就是新的状态。</p>

<p><strong>2.我们再将这个 <code>f</code> 函数给 Redux 的 Store 去管理</strong></p>

<p><code>javascript
/**
 * 创建 Redux 的 Store(存储器)
*/
let store = createStore(coordinates);
</code></p>

<p>这个比较简单，就是通过传入 <code>f</code> 来创建一个 Store，对于 Redux 来说有且只有一个 Store，这个和 flux 有比较大的差别。</p>

<p><strong>3.然后再定义一个行为，使我们能够通过 dispatch 调用这个行为去改变 state</strong></p>

<p><code>javascript
/**
 * action
*/
const CLICK = 'CLICK';
/**
 * @returns plainObject =&gt; action
 */
function click() {
	return {
		type: CLICK
	}
}
</code></p>

<p>在 Redux 中，只有通过 <code>dispatch</code> 方法去改变状态，就是因为这样，才让我们调试代码变得简单，复现 BUG 更加容易，因为它是单向的，顺着一个方向在流动数据。</p>

<p><strong>4.接下来就写一下 dispatch</strong></p>

<p><code>javascript
plane.events.onInputDown.add(() =&gt; {
	store.dispatch(click())
}, null);
</code></p>

<p>先抛开其他代码，我们剥离一下：</p>

<p><code>javascript
store.dispatch(click())
</code></p>

<p>这样就会去调用行为，然后执行我们上面定义的 <code>coordinates</code> 函数，返回一个新的坐标</p>

<p><strong>5.最后我们再订阅一下具体改变我们飞机位置的业务代码</strong></p>

<p>上面的写完后，我们只是返回来状态，但是还没体现到飞机在场景下的移动效果。我们能够通过</p>

<p><code>javascript
store.getState()
</code></p>

<p>来获取最新的当前状态，其实在 Redux 源代码里面就是很简单的一个函数：</p>

<p><code>javascript
function getState() {
	// 这里的 currentState 是一个外部的变量，在 Store 的作用域下全局生效
	return currentState;
}
</code></p>

<p>好吧，现在我们让飞机订阅一下移动的函数：</p>

<p><code>javascript
/**
* 定义 plane(飞机) 的移动
*/
function movePlane(plane) {
	game.add.tween(plane).to({
		x: store.getState()[0],
		y: store.getState()[1]
	}, 1000, 'Linear', true);
}
/**
* 移动事件的订阅
*/
store.subscribe(movePlane.bind(null, plane));
</code></p>

<p>大家会想，为什么我订阅了就自动调用 movePlane 生效了呢？在 Redux 内部会调用当前的监听器，源代码如下，很简单，监听器就是一个数组来装的，最后移出来执行一下：</p>

<p>``` javascript
function subscribe(listener) {
	var isSubscribed = true;</p>

<pre><code>ensureCanMutateNextListeners();
nextListeners.push(listener);

// 然后会返回一个取消订阅的函数，这里省略 } function dispatch(action) {
// 省略一些杂七杂八的异常处理代码

try {
	isDispatching = true;
	currentState = currentReducer(currentState, action);
} finally {
	isDispatching = false;
}

// 执行的代码
var listeners = currentListeners = nextListeners;
for (var i = 0; i &lt; listeners.length; i++) {
	listeners[i]();
}

return action; } ```
</code></pre>

<p>好吧，这样就是一个游戏的流程来，在 Redux 的帮助下，很好的组织了代码，优雅的完成了。执行代码的流程是这样的：</p>

<blockquote>
  <p>dispatch(click()) =&gt; update reducer =&gt; subscribe() =&gt; 飞机移动新位置</p>
</blockquote>

<p>这个例子很好的解释了脱离 React 的束缚，很纯粹的 Redux，原文翻译有点慢，干脆就自己写了一下。</p>

<p>项目所有的代码：<a href="https://github.com/fegg/redux-game">https://github.com/fegg/redux-game</a></p>

<p>参考英文原文：<a href="http://atendesigngroup.com/blog/redux-outside-react">http://atendesigngroup.com/blog/redux-outside-react</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React 组件开发入门]]></title>
    <link href="http://fegg.github.io/blog/20150726/induction-react-component-dev/"/>
    <updated>2015-07-26T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20150726/induction-react-component-dev</id>
    <content type="html"><![CDATA[<h3 id="section">前言</h3>

<p>熟悉 React 的思想后，我们先来尝试开发一个单纯的小组件，可以对比一下是不是比以前的开发模式更加舒适了，这里我主要以一个 Loadding 组件来举栗子，实现了几个基本的功能：</p>

<ul>
  <li>一种类型的 loadding（菊花转）</li>
  <li>能够设置 loadding 的三个属性：width height color</li>
  <li>能够控制 loadding 的显示和隐藏</li>
</ul>

<p>其实对于一个简单需求来说，这三个属性已经很实用了。但是去网上看一些外国大神写的组件，有一些不明白的地方，所以自己就慢慢搞，do it！</p>

<h3 id="section-1">设计</h3>

<p>我想这样用 loadding 组件：</p>

<p><img src="/images/react/code-loadding.png" alt="使用代码" /></p>

<!-- more -->

<p>所以我定义这个组件的基本结构如下：</p>

<pre><code>var Loadding = React.createClass({
	// 控制组件属性的类型
	propTypes: {},
	// 控制组件属性的默认值
	getDefaultProps: function () {},
	// 组装基本的内联样式
	getComponentStyle: function () {},
	// 渲染基本的组件，拆分 render 方法的粒度
	renderBaseComp: function () {},
	// 最终的渲染方法
	render: function () {}
});
</code></pre>

<p>这个组件中，我使用的 内联样式 来控制组件的内部基本样式的稳定。其实有时候我们会觉得内联样式不好，但是我个人觉得每一种设置 CSS 形式的方法，用在合适的场景中就是正确的。</p>

<p>每部分的具体实现如下，代码中有一些讲解（这里我不会介绍具体 loadding 效果是怎么出来的，看代码应该就会明白，主要介绍一个 react 制作简单组件的思路和写法）对于扩展性来说，</p>

<blockquote>
  <p>你还可以加入 className 和 type 这些修饰性的属性，但是我更倾向于迭代式的组件开发，小组件就要具有良好的封闭性，使用接口简单，大组件才考虑更好的鲁棒性和可扩展性，这样开发一个组件的性价比才高。需要注意对 getDefaultProps 的理解，只有当使用接口的人代码中根本没有写那个属性的时候，才会使用定义的默认值。</p>
</blockquote>

<h3 id="section-2">实现</h3>

<pre><code>var Loadding = React.createClass({
	propTypes: {
		width: React.PropTypes.oneOfType([
			React.PropTypes.number,
			React.PropTypes.string
		]),
		height: React.PropTypes.oneOfType([
			React.PropTypes.number,
			React.PropTypes.string
		]),
		color: React.PropTypes.string,
		active: React.PropTypes.bool
	},
	getDefaultProps: function() {
		return {
			color: '#00be9c',
			height: 30,
			width: 30,
			active: false
		};
	},

	getComponentStyle: function() {
		var width = this.props.width,
			height = this.props.height,
			color = this.props.color;
		/* 中间圆心 */
		var cWidth = 0.4 * width,
			cHeight = 0.4 * height,
			cMarginLeft = -0.5 * cWidth,
			cMarginTop = -0.5 * cHeight;

		/* 基本样式 */
		return {
			loaddingStyle: { // loadding 容器
				width: width,
				height: height
			},
			lineStyle: { // loadding 元件样式
				background: color
			},
			centerStyle: { // loadding 圆心样式
				width: cWidth,
				height: cHeight,
				marginLeft: cMarginLeft,
				marginTop: cMarginTop
			}
		};
	},

	renderBaseComp: function(compStyle) {
		/* 生成动画元件 */
		var n = 4; // 元件个数，todo: 定制个数
		var lines = []; // 元件元素集合
		for (var i = 0; i &lt; n; i++) {
			lines.push(
				&lt;div className="line"&gt;
					&lt;span className="top" style={ compStyle.lineStyle }&gt;&lt;/span&gt;
					&lt;span className="bottom" style={ compStyle.lineStyle }&gt;&lt;/span&gt;
				&lt;/div&gt;
			);
		}
		return lines;
	},

	render: function() {
		/* 生成组件自己的样式 */
		var compStyle = this.getComponentStyle();
		/* 模拟渲染基本动画元件 */
		var lines = this.renderBaseComp(compStyle);

		// loadding 的class，控制交互
		var loaddingClasses = cx({
			loadding: true,
			active: this.props.active
		});

		return (
			&lt;div className={ loaddingClasses } style={ compStyle.loaddingStyle }&gt;
				{lines}
				&lt;div className="loadding-center" style={ compStyle.centerStyle }&gt;&lt;/div&gt;
			&lt;/div&gt;

		);
	}

});
</code></pre>

<p>最后，下面是基本的 SASS（不考虑不支持的情况，不支持都不用开发，直接用图，性价比更高）</p>

<pre><code>@include keyframes(load) {
	0% {
		opacity: 0;
	}
	25% {
		opacity: .25;
	}
	50% {
		opacity: .5;
	}
	75% {
		opacity: .75;
	}
	100% {
		opacity: 1;
	}
}

.loadding {
	display: none;
	position: absolute;
	&amp;.active {
		display: block;
	}
	.loadding-center {
		position: absolute;
		left: 0;
		top: 50%;
		background: #fff;
		border-radius: 50%;
	}
	.line {
		position: absolute;
		top: 0;
		left: 0;
		height: 100%;
		.top {
			content: '';
			display: block;
			width: 1px;
			font-size: 0;
			height: 50%;
		}
		.bottom {
			@extend .top;
		}
		@for $i from 1 through 4 {
			&amp;:nth-child(#{$i}) {
				transform:rotate(45deg * ($i - 1));
				.top {
					@include animation(load, 0.8s, linear, 0s, infinite);
				}
				.bottom {
					@include animation(load, 0.8s, linear, 0.4s + $i/10, infinite);
				}
			}
		}
	}
}
</code></pre>

<p>里面用到的一个 animation 混淆方法：</p>

<pre><code>@mixin keyframes($name) {
	@-webkit-keyframes #{$name} {
		@content;
	}
	@-moz-keyframes #{$name} {
		@content;
	}
	@-ms-keyframes #{$name} {
		@content;
	}
	@keyframes #{$name} {
		@content;
	}
}

@mixin animation ($name, $duration, $func, $delay, $count, $direction: normal) {
	-webkit-animation: $name $duration $func $delay $count $direction;
	-moz-animation: $name $duration $func $delay $count $direction;
	-o-animation: $name $duration $func $delay $count $direction;
	animation: $name $duration $func $delay $count $direction;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React 组件之间如何交流]]></title>
    <link href="http://fegg.github.io/blog/20150719/react-component-communicate/"/>
    <updated>2015-07-19T00:00:00+08:00</updated>
    <id>http://fegg.github.io/blog/20150719/react-component-communicate</id>
    <content type="html"><![CDATA[<h3 id="section">前言</h3>

<p>今天群里面有很多都在问关于 React 组件之间是如何通信的问题，之前自己写的时候也遇到过这类问题。下面是我看到的一篇不错英文版的翻译，看过我博客的人都知道，我翻译可能不会按部就班，会尽可能用中文的意思，来将作者要讲述的技术描述清楚。英文能力有限，如果有不对的地方请跟我留言，一定修改……^_^</p>

<h3 id="section-1">原著序</h3>

<p>处理 React 组件之间的交流方式，主要取决于组件之间的关系，然而这些关系的约定人就是你。</p>

<p>我不会讲太多关于 data-stores、data-adapters 或者 data-helpers 之类的话题。我下面只专注于 React 组件本身的交流方式的讲解。</p>

<p>React 组件之间交流的方式，可以分为以下 3 种：</p>

<ul>
  <li>【父组件】向【子组件】传值；</li>
  <li>【子组件】向【父组件】传值；</li>
  <li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）</li>
</ul>

<!-- more -->

<h3 id="section-2">一、【父组件】向【子组件】传值</h3>

<blockquote>
  <p>初步使用</p>
</blockquote>

<p>这个是相当容易的，在使用 React 开发的过程中经常会使用到，主要是利用 props 来进行交流。例子如下：</p>

<p>``` javascript
// 父组件
var MyContainer = React.createClass({
	getInitialState: function () {
		return {
			checked: true
		};
	},
	render: function() {
		return (
			&lt;ToggleButton text=”Toggle me” checked={this.state.checked} /&gt;
		);
	}
});</p>

<p>// 子组件
var ToggleButton = React.createClass({
	render: function () {
		// 从【父组件】获取的值
		var checked = this.props.checked,
				text = this.props.text;</p>

<pre><code>	return (
			&lt;label&gt;{text}: &lt;input type="checkbox" checked={checked} /&gt;&lt;/label&gt;
	);
} }); ```
</code></pre>

<blockquote>
  <p>进一步讨论</p>
</blockquote>

<p>如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）</p>

<p>``` javascript
// 父组件
var MyContainer = React.createClass({
	render: function() {
		return (
			<Intermediate text="where is my son?"></Intermediate>
		);
	}
});</p>

<p>// 子组件1：中间嵌套的组件
var Intermediate = React.createClass({
	render: function () {
		return (
			&lt;Child text={this.props.text} /&gt;
		);
	}
});</p>

<p>// 子组件2：子组件1的子组件
var Child = React.createClass({
	render: function () {
		return (
			<span>{this.props.text}</span>
		);
	}
});
```</p>

<h3 id="section-3">二、【子组件】向【父组件】传值</h3>

<p>接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。</p>

<p>``` javascript
// 父组件
var MyContainer = React.createClass({
	getInitialState: function () {
		return {
			checked: false
		};
	},
	onChildChanged: function (newState) {
		this.setState({
			checked: newState
		});
	},
	render: function() {
		var isChecked = this.state.checked ? ‘yes’ : ‘no’;
		return (
			&lt;div&gt;
				&lt;div&gt;Are you checked: {isChecked}&lt;/div&gt;
				&lt;ToggleButton text=”Toggle me”
					initialChecked={this.state.checked}
					callbackParent={this.onChildChanged}
					/&gt;
			&lt;/div&gt;
		);
	}
});</p>

<p>// 子组件
var ToggleButton = React.createClass({
	getInitialState: function () {
		return {
			checked: this.props.initialChecked
		};
	},
	onTextChange: function () {
		var newState = !this.state.checked;
		this.setState({
			checked: newState
		});
		// 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值
		this.props.callbackParent(newState);
	},
	render: function () {
		// 从【父组件】获取的值
		var text = this.props.text;
		// 组件自身的状态数据
		var checked = this.state.checked;</p>

<pre><code>	return (
			&lt;label&gt;{text}: &lt;input type="checkbox" checked={checked} 				onChange={this.onTextChange} /&gt;&lt;/label&gt;
	);
} }); ```
</code></pre>

<p><img src="/images/react/demo3.gif" alt="运行效果" /></p>

<p>我觉得原文作者用代码不是很直观，接下来我话一个流程走向简图来直观描述一下这个过程：</p>

<p><img src="/images/react/comp-child-to-parent.png" alt="流程简图" /></p>

<blockquote>
  <p>这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式</p>
</blockquote>

<p>这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。</p>

<h3 id="tiny-tip-react-event-system">Tiny-Tip: React Event System</h3>

<p>在 onChange 事件或者其他 React 事件中，你能够获取以下东西：</p>

<ul>
  <li>【this】：指向你的组件</li>
  <li>【一个参数】：这个参数是一个 <a href="http://wiki.jikexueyuan.com/project/react/event-system.html">React 合成事件</a>，SyntheticEvent。</li>
</ul>

<p>React 对所有事件的管理都是自己实现的，与我们之前使用的 onclick、onchange 事件不一样。从根本上来说，他们都是绑定到 body 上。</p>

<p><code>javascript
document.on('change', 'input[data-reactid=".0.2"]', function () {...});
</code></p>

<p>上面这份代码不是来自于 React，只是打一个比方而已。</p>

<p>如果我没有猜错的话，React 真正处理一个事件的代码如下：</p>

<p><code>javascript
var listenTo = ReactBrowserEventEmitter.listenTo;
...
function putListener(id, registrationName, listener, transaction) {
	...
	var container = ReactMount.findReactContainerForID(id);
	if (container) {
		var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
		listenTo(registrationName, doc);
		}
	...
}
// 在监听事件的内部，我们能发现如下：
target.addEventListener(eventType, callback, false);
</code></p>

<p>这里有所有 React 支持的事件：<a href="http://reactjs.cn/react/docs/events.html">中文文档-事件系统</a></p>

<blockquote>
  <p>多个子组件使用同一个回调的情况</p>
</blockquote>

<p>``` javascript
// 父组件
var MyContainer = React.createClass({
	getInitialState: function () {
		return {
			totalChecked: 0
		};
	},
	onChildChanged: function (newState) {
		var newToral = this.state.totalChecked
			+ (newState ? 1 : -1);
		this.setState({
			totalChecked: newToral
		});
	},
	render: function() {
		var totalChecked = this.state.totalChecked;
		return (
			&lt;div&gt;
				&lt;div&gt;How many are checked: {totalChecked}&lt;/div&gt;
				&lt;ToggleButton text=”Toggle me”
					initialChecked={this.state.checked}
					callbackParent={this.onChildChanged}
					/&gt;
				&lt;ToggleButton text=”Toggle me too”
						initialChecked={this.state.checked}
						callbackParent={this.onChildChanged}
						/&gt;
					&lt;ToggleButton text=”And me”
						initialChecked={this.state.checked}
						callbackParent={this.onChildChanged}
						/&gt;
			&lt;/div&gt;
		);
	}
});</p>

<p>// 子组件
var ToggleButton = React.createClass({
	getInitialState: function () {
		return {
			checked: this.props.initialChecked
		};
	},
	onTextChange: function () {
		var newState = !this.state.checked;
		this.setState({
			checked: newState
		});
		// 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值
		this.props.callbackParent(newState);
	},
	render: function () {
		// 从【父组件】获取的值
		var text = this.props.text;
		// 组件自身的状态数据
		var checked = this.state.checked;</p>

<pre><code>	return (
			&lt;label&gt;{text}: &lt;input type="checkbox" checked={checked} onChange={this.onTextChange} /&gt;&lt;/label&gt;
	);
} }); ```
</code></pre>

<p><img src="/images/react/demo4.gif" alt="运行结果" /></p>

<p>这是非常容易理解的，在父组件中我们增加了一个【totalChecked】来替代之前例子中的【checked】，当子组件改变的时候，使用同一个子组件的回调函数给父组件返回值。</p>

<h3 id="section-4">三、没有任何嵌套关系的组件之间传值</h3>

<p>如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。</p>

<p>下面讲介绍 3 种模式来处理事件，你能<a href="https://github.com/millermedeiros/js-signals/wiki/Comparison-between-different-Observer-Pattern-implementations">点击这里</a>来比较一下它们。</p>

<p>简单总结一下：</p>

<p>(1) Event Emitter/Target/Dispatcher</p>

<p>特点：需要一个指定的订阅源</p>

<p><code>javascript
// to subscribe
otherObject.addEventListener(‘click’, function() { alert(‘click!’); });
// to dispatch
this.dispatchEvent(‘click’);
</code></p>

<p>(2) Publish / Subscribe</p>

<p>特点：触发事件的时候，你不需要指定一个特定的源，因为它是使用一个全局对象来处理事件（其实就是一个全局
广播的方式来处理事件）</p>

<p><code>javascript
// to subscribe
globalBroadcaster.subscribe(‘click’, function() { alert(‘click!’); });
// to dispatch
globalBroadcaster.publish(‘click’);
</code></p>

<p>(3) Signals</p>

<p>特点：与Event Emitter/Target/Dispatcher相似，但是你不要使用随机的字符串作为事件触发的引用。触发事件的每一个对象都需要一个确切的名字（就是类似硬编码类的去写事件名字），并且在触发的时候，也必须要指定确切的事件。（看例子吧，很好理解）</p>

<p><code>javascript
// to subscribe
otherObject.clicked.add(function() { alert(‘click’); });
// to dispatch
this.clicked.dispatch();
</code></p>

<p>如果你只想简单的使用一下，并不需要其他操作，可以用简单的方式来实现：</p>

<p><code>javascript
// 简单实现了一下 subscribe 和 dispatch
var EventEmitter = {
		_events: {},
		dispatch: function (event, data) {
				if (!this._events[event]) { // 没有监听事件
					return;
				}
				for (var i = 0; i &lt; this._events[event].length; i++) {
						this._events[event][i](data);
				}
		},
		subscribe: function (event, callback) {
			// 创建一个新事件数组
			if (!this._events[event]) {
				this._events[event] = [];
			}
			this._events[event].push(callback);
		}
};
otherObject.subscribe('namechanged', function(data) { alert(data.name); });
this.dispatch('namechanged', { name: 'John' });
</code></p>

<p>如果你想使用 Publish/Subscribe 模型，可以使用：<a href="https://github.com/mroderick/PubSubJS">PubSubJS</a></p>

<p>React 团队使用的是：<a href="http://millermedeiros.github.io/js-signals/">js-signals</a> 它基于 Signals 模式，用起来相当不错。</p>

<h3 id="events-in-react">Events in React</h3>

<p>使用 React 事件的时候，必须关注下面两个方法：</p>

<p><code>javascript
componentDidMount
componentWillUnmount
</code></p>

<p>在处理事件的时候，需要注意：</p>

<p>在 componentDidMount 事件中，如果组件挂载（mounted）完成，再订阅事件；当组件卸载（unmounted）的时候，在 componentWillUnmount 事件中取消事件的订阅。</p>

<p>（如果不是很清楚可以查阅 React 对生命周期介绍的文档，里面也有描述。原文中介绍的是 componentWillMount 个人认为应该是挂载完成后订阅事件，比如Animation这个就必须挂载，并且不能动态的添加，谨慎点更好）</p>

<p>因为组件的渲染和销毁是由 React 来控制的，我们不知道怎么引用他们，所以EventEmitter 模式在处理组件的时候用处不大。</p>

<p>pub/sub 模式可以使用，你不需要知道引用。</p>

<p>下面来一个例子：实现有多个 product 组件，点击他们的时候，展示 product 的名字。</p>

<p>(我在例子中引入了之前推荐的 PubSubJS 库，如果你觉得引入代价太大，也可以手写一个简版，还是比较容易的，很好用哈，大家也可以体验，但是我还是不推荐全局广播的方式)</p>

<p><code>javascript
// 定义一个容器
var ProductList = React.createClass({
		render: function () {
			return (
				&lt;div&gt;
					&lt;ProductSelection /&gt;
					&lt;Product name="product 1" /&gt;
					&lt;Product name="product 2" /&gt;
					&lt;Product name="product 3" /&gt;
				&lt;/div&gt;
			);
		}
});
// 用于展示点击的产品信息容器
var ProductSelection = React.createClass({
	getInitialState: function() {
		return {
			selection: 'none'
		};
	},
	componentDidMount: function () {
		this.pubsub_token = PubSub.subscribe('products', function (topic, product) {
			this.setState({
				selection: product
			});
		}.bind(this));
	},
	componentWillUnmount: function () {
		PubSub.unsubscribe(this.pubsub_token);
	},
	render: function () {
		return (
			&lt;p&gt;You have selected the product : {this.state.selection}&lt;/p&gt;
		);
	}
});
var Product = React.createClass({
	onclick: function () {
		PubSub.publish('products', this.props.name);
	},
	render: function() {
		return &lt;div onClick={this.onclick}&gt;{this.props.name}&lt;/div&gt;;
	}
});
</code></p>

<p><img src="/images/react/demo5.gif" alt="运行结果" /></p>

<h3 id="es6-yield-and-js-csp">ES6: yield and js-csp</h3>

<p>ES6 中有一种传递信息的方式，使用生成函数(generators)和 yield 关键字。可以看一下 <a href="https://github.com/ubolonton/js-csp">https://github.com/ubolonton/js-csp</a></p>

<p>（这里我写一个简单的 DEMO 介绍一下这种新的传递方式，其实大同小异）</p>

<p><code>javascript
function* list() {
		for(var i = 0; i &lt; arguments.length; i++) {
				yield arguments[i];
		}
		return "done.";
}
var o = list(1, 2, 3);
var cur = o.next;
while(!cur.done) {
		cur = o.next();
		console.log(cur);
}
</code></p>

<p>以上例子来自于屈屈的一篇博客：<a href="http://imququ.com/post/generator-function-in-es6.html">ES6 中的生成器函数介绍</a> 屈屈是一个大牛，大家可以经常关注他的博客。</p>

<p>通常来说，你有一个队列，对象在里面都能找到一个引用，在定义的时候锁住，当发生的时候，立即打开锁执行。js-csp 是一种解决办法，也许以后还会有其他解决办法。</p>

<h3 id="section-5">结尾</h3>

<p>在实际应用中，按照实际要解决的需求选择解决办法。对于小应用程序，你可以使用 props 和回调的方法进行组件之间的数据交换。你可以通过 pub/sub 模式，以避免污染你的组件。在这里，我们不是在谈论数据，只是组件。对于数据的请求、数据的变化等场景，可以使用 Facebook 的 Flux、Relay、GraphQL 来处理，都非常的好用。</p>

<blockquote>
  <p>文中的每一个例子我都验证过了，主要使用最原始的引入文件方式，创建服务使用的 http-server 包，大家也可以尝试自己来一次。</p>
</blockquote>

<p>译：<a href="http://ctheu.com/2015/02/12/how-to-communicate-between-react-components/#child_to_parent">英文原版</a></p>

]]></content>
  </entry>
  
</feed>
